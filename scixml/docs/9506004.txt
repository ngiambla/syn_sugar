 Many theories of semantic interpretation use  - term manipulation to compositionally compute the meaning of a sentence . 
 These theories are usually implemented in a language such as Prolog that can simulate  - term operations with first-order unification . 
 However , for some interesting cases , such as a Combinatory Categorial Grammar account of coordination constructs , this can only be done by obscuring the underlying linguistic theory with the `` tricks '' needed for implementation . 
 This paper shows how the use of abstract syntax permitted by higher-order logic programming allows an elegant implementation of the semantics of Combinatory Categorial Grammar , including its handling of coordination constructs . 
 Many theories of semantic interpretation use  - term manipulation to compositionally compute the meaning of a sentence . 
 These theories are usually implemented in a language such as Prolog that can simulate  - term operations with first-order unification . 
 However , there are cases in which this can only be done by obscuring the underlying linguistic theory with the `` tricks '' needed for implementation . 
 For example , Combinatory Categorial Grammar ( CCG ) Steedman 1990 is a theory of syntax and semantic interpretation that has the attractive characteristic of handling many coordination constructs that other theories cannot . 
 While many aspects of CCG semantics can be reasonably simulated in first-order unification , the simulation breaks down on some of the most interesting cases that CCG can theoretically handle . 
 The problem in general , and for CCG in particular , is that the implementation language does not have sufficient expressive power to allow a more direct encoding . 
 The solution given in this paper is to show how advances in logic programming allow the implementation of semantic theories in a very direct and natural way , using CCG as a case study . 
 We begin by briefly illustrating why first-order unification is inadequate for some coordination constructs , and then review two proposed solutions . 
 The sentence in  usually has the logical form ( LF ) in  . 
 CCG is one of several theories in which  gets derived by raising John to be the LF  , where P is a predicate that takes a NP as an argument to return a sentence . 
 Likewise , Bill gets the LF  , and coordination results in the following LF for John and Bill : 
 When  is applied to the predicate ,  will result after  - reduction . 
 However , under first-order unification , this needs to simulated by having the variable x in  unify both with Bill and John , and this is not possible . 
 See Jowsey 1990 and Moore 1989 for a thorough discussion . 
 Moore 1989 suggests that the way to overcome this problem is to use explicit  - terms and encode  - reduction to perform the needed reduction . 
 For example , the logical form in  would be produced , where  is the representation of  . 
 This would then be reduced by the clauses for apply to result in  . 
 For this small example , writing such an apply predicate is not difficult . 
 However , as the semantic terms become more complex , it is no trivial matter to write  - reduction that will correctly handle variable capture . 
 Also , if at some point it was desired to determine if the semantic forms of two different sentences were the same , a predicate would be needed to compare two lambda forms for  - equivalence , which again is not a simple task . 
 Essentially , the logic variable X is meant to be interpreted as a bound variable , which requires an additional layer of programming . 
 Park 1992 proposes a solution within first-order unification that can handle not only sentence  , but also more complex examples with determiners . 
 The method used is to introduce spurious bindings that subsequently get removed . 
 For example , the semantics of  would be  , which would then get simplified to  . 
 While this pushes first-order unification beyond what it had been previously shown capable of , there are two disadvantages to this technique : 
 For every possible category that can be conjoined , a separate lexical entry for and is required , and 
 As the conjoinable categories become more complex , the and entries become correspondingly more complex and greatly obscure the theoretical background of the grammar formalism . 
 The fundamental problem in both cases is that the concept of free and bound occurrences of variables is not supported by Prolog , but instead needs to be implemented by additional programming . 
 While theoretically possible , it becomes quite problematic to actually implement . 
 The solution given in this paper is to use a higher-order logic programming language , -Prolog , that already implements these concepts , called `` abstract syntax '' in Miller 1991 and `` higher-order abstract syntax '' in Pfenning and Elliot 1988 . 
 This allows a natural and elegant implementation of the grammatical theory , with only one lexical entry for and . 
 This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics Miller and Nadathur 1986 , Pareschi 1989 , Pereira 1990 . 
 CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition at the level of syntax and logical form . 
 Each word is ( perhaps ambiguously ) assigned a category and LF , and when the syntactical operations assign a new category to a constituent , the corresponding semantic operations produce a new LF for that constituent as well . 
 The CCG rules  shown in Figure  are implemented in the system described in this paper . 
 Each of the three operations have both a forward and backward variant . 
 As an illustration of how the semantic rules can be simulated in first-order unification , consider the derivation of the constituent harry found , where harry has the category np with LF harry ' and found is a transitive verb of category  with LF 
 In the CCG formalism , the derivation is as follows : harry gets raised with the # GT T rule , and then forward composed by the # GT B rule with found , and the result is a category of type s / np with LF  . 
 In section  it will be seen how the use of abstract syntax allows this to be expressed directly . 
 In first-order unification , it is simulated as shown in Figure  . 
 The final CCG rule to be considered is the coordination rule that specifies that only like categories can coordinate : 
 This is actually a schema for a family of rules , collectively called `` generalized coordination '' , since the semantic rule is different for each case . 
 For example , if X is a unary function , then the semantic rule is  , and if the functions have two arguments , then the rule is  . 
 For example , when processing  , rule  would be used with : 
 with the result 
 which is  - equivalent to  . 
 -Prolog is a logic programming language based on higher-order hereditary Harrop formulae Miller et al. 1991 . 
 It differs from Prolog in that first-order terms and unification are replaced with simply-typed  - terms and higher-order unification , respectively . 
 It also permits universal quantification and implication in the goals of clauses . 
 The crucial aspect for this paper is that together these features permits the usage of abstract syntax to express the logical forms terms computed by CCG . 
 The built-in  - term manipulation is used as a `` meta-language '' in which the `` object-language '' of CCG logical forms is expressed , and variables in the object-language are mapped to variables in the meta-language . 
 The -Prolog code fragment shown in Figure  declares how the CCG logical forms are represented . 
 Each CCG LF is represented as an untyped  - term , namely type tm. abs represents object-level abstraction  by the meta-level expression ( abs N ) , where N is a meta-level function of type  . 
 A meta-level  - abstraction  is written  . 
 Thus , if walked ' has type  , then  is a -Prolog ( meta-level ) function with type  , and  is the object-level representation , with type tm . 
 The LF for found shown in  would be represented as  . 
 app encodes application , and so in the derivation of harry found , the type-raised harry has the -Prolog value  . 
 The second part of Figure  shows declares how quantifiers are represented , which are required since the sentences to be processed may have determiners . 
 forall and exists are encoded similarly to abstraction , in that they take a functional argument and so object-level binding of variables by quantifiers is handled by meta-level  - abstraction . 
  and  are simple constructors for implication and conjunction , to be used with forall and exists respectively , in the typical manner Pereira and Shieber 1987 . 
 For example , the sentence `` every man found a bone '' has as a possible LF  , with the -Prolog representation  : 
 Figure  illustrates how directly the CCG operations can be encoded . 
 o is the type of a meta-level proposition , and so the intended usage of apply is to take three arguments of type tm , where the first should be an object-level  - abstraction , and set the third equal to the application of the first to the second . 
 Thus , for the query 
 R unifies with the  function  , S with harry ' and M with ( R S ) , the meta-level application of R to S , which by the built-in  - reduction is  . 
 In other words , object-level function application is handled simply by the meta-level function application . 
 Function composition is similar . 
 Consider again the derivation of harry found by type-raising and forward composition . 
 harry would get type-raised by the raise clause to produce  , and then composed with found , with the result shown in the following query : 
 At this point a further  - reduction is needed . 
 Note however this is not at all the same problem of writing a  - reducer in Prolog . 
 Instead it is a simple matter of using the meta-level  - reduction to eliminate  - redexes to produce the final result  . 
 We won't show the complete declaration of the  - reducer , but the key clause is simply : 
 Thus , using the abstract syntax capabilities of -Prolog , we can have a direct implementation of the underlying linguistic formalism , in stark contrast to the first-order simulation shown in Figure  . 
 A primary goal of abstract-syntax is to support recursion through abstractions with bound variables . 
 This leads to the interpretation of a bound variable as a `` scoped constant '' - it acts like a constant that is not visible from the top of the term , but which becomes visible during the descent through the abstraction . 
 See Miller 1991 for a discussion of how this may be used for evaluation of functional programs by `` pushing '' the evaluation through abstractions to reduce redexes that are not at the top-level . 
 This technique is also used in the  - reducer briefly mentioned at the end of the previous section , and a similar technique will be used here to implement coordination by recursively descending through the two arguments to be coordinated . 
 Before describing the implementation of coordination , it is first necessary to mention how CCG categories are represented in the -Prolog code . 
 As shown in Figure  , cat is declared to be a primitive type , and np , s , conj , noun are the categories used in this implementation . 
 fs and bs are declared to be constructors for forward and backward slash . 
 For example , the CCG category for a transitive verb  would be represented as  . 
 Also , the predicate atomic-type is declared to be true for the four atomic categories . 
 This will be used in the implementation of coordination as a test for termination of the recursion . 
 The implementation of coordination crucially uses the capability of -Prolog for universal quantification in the goal of a clause . 
 pi is the meta-level operator for  , and  is written as  . 
 The operational semantics for -Prolog state that  is provable if and only if [ c / x ] G is provable , where c is a new variable of the same type as x that does not otherwise occur in the current signature . 
 In other words , c is a scoped constant and the current signature gets expanded with c for the proof of [ c / x ] G. Since c is meant to be treated as a generic placeholder for any arbitrary x of the proper type , c must not appear in any terms instantiated for logic variables during the proof of [ c / x ] G . 
 The significance of this restriction will be illustrated shortly . 
 The code for coordination is shown in Figure  . 
 The four arguments to coord are a category and three terms that are the object-level LF representations of constituents of that category . 
 The last argument will result from the coordination of the second and third arguments . 
 Consider again the earlier problematic example  of coordination . 
 Recall that after john is type-raised , its LF will be  and similarly for bill . 
 They will both have the category  . 
 Thus , to obtain the LF for John and Bill , the following query would be made : 
 This will match with the first clause for coord , with 
 A instantiated to ( bs np s ) 
 B to s 
 R to  
 S to  
 and T a logic variable waiting instantiation . 
 Then , after the meta-level  - reduction using the new scoped constant c , the following goal is called : 
 where N = ( T c ) . 
 Since s is an atomic type , the third coord clause matches with 
 B instantiated to s 
 R to  
 S to 
 N to  
 Since N = ( T c ) , higher-order unification is used by -Prolog to instantiate T by extracting c from N with the result . 
 and so M from the original query is 
 Note that since c is a scoped constant arising from the proof of an universal quantification , the instantiation  
 is prohibited , along with the other extractions that do not remove c from the body of the abstraction . 
 This use of universal quantification to extract out c from a term containing c in this case gives the same result as a direct implementation of the rule for cooordination of unary functions  would . 
 However , this same process of recursive descent via scoped constants will work for any member of the conj rule family . 
 For example , the following query 
 corresponds to rule  . 
 Note also that the use of the same bound variable names obj and sub causes no difficulty since the use of scoped-constants , meta-level  - reduction , and higher-order unification is used to access and manipulate the inner terms . 
 Also , whereas Park 1992 requires careful consideration of handling of determiners with coordination , here such sentences are handled just like any others . 
 For example , the sentence `` Mary gave every dog a bone and some policeman a flower '' results in the LF : 
 Thus , `` generalized coordination '' , instead of being a family of separate rules , can be expressed as a single rule on recursive descent through logical forms . 
 Steedman 1990 also discusses `` generalized composition '' , and it may well be that a similar implementation is possible for that family of rules as well . 
 We have shown how higher-order logic programming can be used to elegantly implement the semantic theory of CCG , including the previously difficult case of its handling of coordination constructs . 
 The techniques used here should allow similar advantages for a variety of such theories . 
 An argument can be made that the approach taken here relies on a formalism that entails implementation issues that are more difficult than for the other solutions and inherently not as efficient . 
 However , the implementation issues , although more complex , are also well-understood and it can be expected that future work will bring further improvements . 
 For example , it is a straightforward matter to transform the -Prolog code into a logic called  Miller 1990 which requires only a restricted form of unification that is decidable in linear time and space . 
 Also , the declarative nature of -Prolog programs opens up the possibility for applications of program transformations such as partial evaluation . 
 This work is supported by ARO grant DAAL03 - 89 - 0031 , DARPA grant N00014 - 90-J - 1863 , and ARO grant DAAH04 - 94-G - 0426 . 
 I would like to thank Aravind Joshi , Dale Miller , Jong Park , and Mark Steedman for valuable discussions and comments on earlier drafts . 
