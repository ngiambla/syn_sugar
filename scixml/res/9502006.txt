 However , there is often a trade-off between run-time efficiency and factors important for rapid and accurate system development , such as perspicuity of notation , ease of debugging , speed of compilation and the size of its output , and the independence of the morphological and lexical components .
 In compilation , one may compose any or all of the two-level rule set , the set of affixes and their allowed combinations , and the lexicon ; see Kaplan and Kay 1994 for an exposition of the mathematical basis .
 The type of compilation appropriate for rapid development and acceptable run-time performance depends on , at least , the nature of the language being described and the number of base forms in the lexicon ; that is , on the position in the three-dimensional space defined by , and .
 For agglutinative languages such as Korean , Finnish and Turkish Kwon and Karttunen 1994 , Koskenniemi 1983 , Oflazer 1993 , dimension is very large , so creating an exhaustive word list is out of the question unless the lexicon is trivial .
 Compilation to a network may still make sense , however , and because these languages tend to exhibit few non-concatenative morphophonological phenomena other than vowel harmony , the continuation class mechanism may suffice to describe the allowed affix sequences at the surface level .
 Compilation of individual spell rules is straightforward ; feature specifications are compiled to positional / boolean format , characters and occurrences of character classes are also converted to boolean vectors , and left contexts are reversed Abramson 1992 for efficiency .
 However , although the obvious spelling rule , allows this change , it does not rule out the incorrect realization of beau + e as * beaue , shown in Figure . because it only affects partitionings where the au at the lexical level forms a single partition , rather than one for a and one for u.
