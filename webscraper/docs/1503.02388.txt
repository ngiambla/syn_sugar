Reproducibility in Research: Systems, Infrastructure, Culture
Tom Crick1, Benjamin A. Hall2 and Samin Ishtiaq3
1Cardi  Metropolitan University, UK
2University of Cambridge, UK
3Microsoft Research Cambridge, UK
1tcrick@cardiffmet.ac.uk
2bh418@mrc-cu.cam.ac.uk
3samin.ishtiaq@microsoft.com
7
1
0
2
 
l
u
J
 
8
2
 
 
]
E
S
.
s
c
[
 
 
2
v
8
8
3
2
0
.
3
0
5
1
:
v
i
X
r
a
Abstract
The reproduction and replication of research results has become a major issue for a number of sci-
enti c disciplines.
In computer science and related computational disciplines such as systems biology,
the challenges closely revolve around the ability to implement (and exploit) novel algorithms and models.
Taking a new approach from the literature and applying it to a new codebase frequently requires local
knowledge missing from the published manuscripts and transient project websites. Alongside this issue,
benchmarking, and the lack of open, transparent and fair benchmark sets present another barrier to the
veri cation and validation of claimed results.
In this paper, we outline several recommendations to address these issues, driven by speci c examples
from a range of scienti c domains. Based on these recommendations, we propose a high-level prototype
open automated platform for scienti c software development which e ectively abstracts speci c depend-
encies from the individual researcher and their workstation, allowing easy sharing and reproduction of
results. This new e-infrastructure for reproducible computational science o ers the potential to incentivise
a culture change and drive the adoption of new techniques to improve the quality and e ciency   and
thus reproducibility   of scienti c exploration.
1 Introduction
Marc Andreessen (co-author of Mosaic, the  rst widely used web browser) boldly stated in 2011 that
 software is eating the world   [1]. This is true: we live in a computational world, with our everyday
communications, entertainment, shopping, banking, transportation, national security, etc, all heavily data-
driven and largely overtaken by software.
Andreessen s statement is particularly true for science and engineering. A 2012 report by the UK s Royal
Society stated that computational techniques have  moved on from assisting scientists in doing science, to
transforming both how science is done and what science is done  [2]. Many of the examples discussed in
this paper exploit a fundamental advantage of computer science and more generally, computational science:
the unique ability for researchers to share the raw outputs of their work as software and data les. New
experiments, simulations, models, benchmarks, even proofs increasingly cannot be done without software.
This software does not consist of simple hack-together, use-once, throw-away scripts; research software
repositories contain thousands, perhaps millions, of lines of code and they increasingly need to be actively
supported and maintained. More importantly, with reproducibility being a fundamental tenet of science,
they need to be open and re-useable.
However, if we closely analyse the scienti c literature related to software tools it often does not appear
to be adhering to these rules [3, 4]. How many of them are open and available? How many explain their
experimental methodologies, in particular the basis for their benchmarking? In particular, can we (re)build
the code? [5] We, the authors, are perhaps as guilty as anyone in the past, where we have published
papers [6, 7] with benchmarks and promises of code to be released in the near future which depreciate as
you move onto the next project.
There are various reasons why the wider scienti c community is in this position. We are currently
undergoing signi cant changes to models of academic dissemination, especially considering the wider open
1
research movement, with new models being proposed [8 10]. Now, numerous  high-impact  journals expli-
citly require that source code and data is made available online under some form of open source license,
but there still exists large disciplinary gaps. While these initiatives are great, they are often optional, seem
piecemeal, and do little to enable the veri cation and validation of scienti c results at a later stage. Even
within the same  eld, there are di erent ideas of what de nes reproducibility [11], as well as evidence of
 overturn bias    replications that overturn original results are much easier to publish than those that
con rm original results [12].
Nevertheless, the reproduction and replication of reported scienti c results has become a widely discussed
topic within the scienti c community [13 15]. Whilst the increasing number of retractions of studies across
a variety of disciplines has drawn the focus of many commentators, automated systems, which allow easy
reproduction of results, o er the potential to improve the e ciency of scienti c exploration and drive the
adoption of new techniques. However, just publishing (linked) scienti c data is not enough to ensure the
required reusability [16]. There exists a wider socio-cultural problem that pervades the scienti c community,
with estimates that as much as 50% of published studies, even those in top-tier academic journals, cannot
be repeated with the same conclusions by an industrial lab [17, 18]. There are numerous non-technical
impediments to making software maintainable and re-useable. The pressure to  make the discovery , publish
quickly and move onto the next project disincentivises careful software curation and preservation. Releasing
code prematurely is often seen to give your competitors an advantage, but we should be shining light into
these  black boxes  [14]; in essence: better software, better research [19].
However, there is promising existing work in this area [20 23], with a variety of manifestos for reprodu-
cible research and community initiatives [24 29], top tips and  ten simple rules  [30 36], as well as analysis
of the wider legal, professional, ethical and risk perspectives [37, 38]. Things can, should and need to be
much better if we want to uphold and maintain the scienti c tenets of openness and sharing. Building upon
previous work [39, 40], we present a call to action, along with a set of recommendations which we hope will
lead to better, more sustainable, more re-useable software, to move towards an imagined future practice and
usage of scienti c software development. We also propose a high-level speci cation for a service that would
automate many of our recommendations.
2 We Need to Talk About Reproducibility
2.1 Can I Implement Your Algorithm?
Reproducibility is a fundamental tenet of high-quality research. Yet many descriptions of algorithms are too
high-level, too obscure, too poorly-de ned to allow an easy re-implementation by a third party. A step in the
algorithm might say:  We pick an element from the frontier set  but which element do you pick? Will the
 rst one do? Why will any element su ce? Sometimes the author would like to give more implementation
detail but is constrained by an arbitrary page limit of a conference or journal paper. Sometimes the authors 
description in-lines other algorithms or data structures that perhaps only that author is familiar with.
Until recently, reproducibility was only discussed at conferences and workshops convened explicitly for
that purpose. This is changing, and a number of high-pro le computer science venues such as the ACM
SIGPLAN conferences POPL and PLDI now explicitly acknowledge the importance of reproducibility, pro-
moting community-driven reviewing and validation of software artefacts.
Recommendation I: We recommend that a paper must describe the algorithm in such a way that it is
implementable by any knowledgeable reader of that algorithm. The description is, of course, subjective, but
to help encourage better descriptions, we also recommend that   in addition to having incentives to support
sharing of computational artefacts   relevant scienti c conferences develop special tracks for papers that
re-implement past papers  algorithms, techniques or tools.
2.2 Set The Code Free
There can be no better proof of your algorithm working, than if you provide the source code of an imple-
mentation; software development is hard, but sharing and re-using code is relatively easy.
Many years ago, Richard Stallman (founder of the GNU Project and Free Software Foundation) pos-
tulated that all code would be free [41] and we would make our money by consulting on the code. As it
turns out, this is now the case for a signi cant part of the computing industry. There are, of course, hard
2
commercial pressures for keeping code closed-source. Even in the scienti c domain, scientists and their
collaborators may wish to hold onto their code as a competitive advantage, especially if there exists larger
competitors who could use the available code to  reverse scoop  the inventors, charging into a promising
new research area opened by the inventors.
Closed source is one thing; licenses that deny the user from viewing, modifying, or sharing the source
are another thing. There are, however, even licences on widely adopted tools like Gaussian [42] (for compu-
tational chemistry) that prohibit even analysing software performance and behaviour. For example, a wide
variety of licenses exist for molecular dynamics software, with di erent degrees of openness e.g. Gromacs uses
the GNU Lesser General Public License (LGPL) [43], CHARMM and Desmond are Academic/Commercial
software licences [44, 45], Amber and NAMD are custom open-like licences. Z3 is an example from the
veri cation area: the code itself was only recently open sourced, but the previous MSR-LA license allowed
the source code to be read, copied, forked for academic use, providing researchers in the  eld substantial
 exibility [46].
Even ignoring licensing issues, sometimes the source is not made open because the author thinks that
it is not quite  nished. You should follow the  release early, release often  mantra, as well as releasing
somewhere public like GitHub, where it is easy to share and fork. Your code is good enough [13].
Recommendation II: There is little doubt that, if scienti c research wants to be open and free, then the
code that underlies it too needs to be open and free. Code that is available for browsing, modifying, and
forking, facilitates testing and comparison. We recommend that code be published under an appropriate
open source license [47]; while we defer legal discussion of the speci cs of any particular licences, BSD and
Apache are good,  exible ones.
2.3 Be A Better Academic Citizen
If you have the appropriate knowledge, skills and experience, you can create better software. We have seen
the emergence of successful initiatives, such as the Software Sustainability Institute (http://www.software.ac.uk)
and the UK Community of Research Software Engineer (http://www.rse.ac.uk), in cultivating world-class
research through software, developing software skills and raising the pro le of research software engineers.
Many scientists will not have had any formal, or even informal, training in scienti c software devel-
opment. Building upon the work of Software Carpentry (http://software-carpentry.org) and Data
Carpentry (http://www.datacarpentry.org), basic training in software engineering concepts like version
control (git, mercurial), unit testing (tests written to exercise the smallest testable parts of a system, like
a function exported from a module), regression testing (a test framework that ensures that previous results
are maintained over the changes in the source code), build tools (Make, scons), etc, can help improve the
quality of the software written enormously [48]. Interestingly, many of these concepts are taught to com-
puter science undergraduates, but it could be argued that they are taught at the wrong time of their careers,
without the experience of complex, long-running projects.
Recommendation III: Software development skills should be regarded as fundamental literacies for sci-
entists and engineers: we recommend that formal programming, data and computational skills are taught
as core at undergraduate and postgraduate level.
2.4 The Lingua Franca of Computational Research
There is no other scienti c or technical  eld where its participants can just make up a non-principled artefact
like a programming language so easily. In a way, it shows how much of a  commons  computer science has
become, that anyone can create a new programming language, API, framework or compiler. This clearly
has its advantages and disadvantages.
High-level languages are generally more readable than their low-level relations. The  density  of a
program is often seen to be a good thing, but it is not always the case that a shorter Haskell program
(for example) is easier to maintain than a longer C++ one; what is important is the readability of the code
itself. A good example here is from the world of automatic theorem proving: the SSRe ect language is much
more readable than the original, standard Coq language [49]. SSRe ect uses mathematicians  vernacular for
script commands, allows reproducibility of automatic proof-checking because parameters are named rather
3
than numbered. Even though these proof scripts are really only ever going to be run by a machine, they
seek to maintain the basic mathematical idea that a proof should be readable by another mathematician.
Many high-level programming languages impose constraints like types: that you can never add a number
and a string is the most basic example, but ML s functors provide principled ways of plugging in compon-
ents with their implementations completely hidden. Aggressive type checking avoids a subset of bugs which
can arise due to incorrectly written functions e.g. well publicised problems with a NASA Mars orbiter
(http://www.cnn.com/TECH/space/9909/30/mars.metric.02/). A further example is a pressure coupling
bug (http://redmine.gromacs.org/issues/14) in Gromacs [43], which arose due to the inappropriate
swapping of a pressure term with a stress tensor. A further extension of types, a concept called units of
measure that is implemented in languages such as F#, can deal with these kinds of bugs at compile time.
Similarly, problems found using in-house software for crystallography led to the retraction of  ve papers [50],
due to a bug which inverted the phases.
Recommendation IV: The use of a principled, high-level, typed programming language in which to write
your software helps hugely with the maintainability, robustness and openness of the software produced.
Even in web frontend work, you have choices: use Typescript or Flow rather than plain old Javascript; use
Hack rather than PHP.
2.5 Lineage (or:  Standing On The Shoulders Of Giants )
Research software is not just software   it is the instantiation of novel algorithms and data structures (or
at least novel applications of data structures). Thus, lineage is important:
Recommendation V: Code should always include links to papers publishing key algorithms and the code
should include explicit relationships to other projects on the repository (i.e. Project B was branched from
Project A). This ensures that both the researchers and software developers working upstream of the current
project are properly credited, encouraging future sharing and development. Remember, the people who did
the research are not necessarily the same people as the developers and maintainers of the software, so it
is important to reward both appropriately with citations: take note of the FORCE11 Software Citation
Principles [51].
2.6 YMMV
Figure 1: #overlyhonestmethods on Twitter by @ianholmes
[source: https://twitter.com/ianholmes/status/288689712636493824]
The tweet in Figure 1 is satirical but worryingly true, highlighting the perils of reproducible research.
4
Often, the tool that the paper describes does not exist for download. Or runs only on one particular bespoke
platform. Or might run for the author, for a while, but will  bit-rot  so quickly that even the author cannot
compile it the following year. Computational reproducibility would appear to be more straightforward than
replicating physical experiments, but the complex and rapidly changing nature of computer systems and
environments that are being used across di erent disciplines makes being able to reproduce and extend such
work a serious challenge [52].
Recommendation VI: You must provide the source code of the tool, but also with details of precisely
how you built and wrote the software. For example:
  you should provide the compiler and build toolchain;
  you should provide build tools (e.g. Make les/Ant/etc) and comprehensive build instructions;
  you should list or link to all non-standard packages and libraries that you use;
  you should note the speci cs of the hardware and OS used.
This may appear to be signi cant extra overhead for researchers, but GitHub APIs, continuous in-
tegration servers, virtual machines and cloud environments can make it easier; see Section 3 for more on
this.
2.7 Data Representations and Formats
We often do not, and should not, care how things are stored on disk, what their precise representations are.
A common, constrained, standard representation is however good for passing tests or models around between
di erent tools. A properly described representation, like the SMT-LIB format (http://smt-lib.org) for
Satis ability Modulo Theory (SMT) solvers, where both the syntax and semantics are well understood,
hugely aids developing tools, techniques and benchmarks.
Another example, from biology, is that of the standard representation of qualitative networks and Boolean
networks [53, 54]. These networks can be expressed in SMV format, but this would mean that standard
qualitative/Boolean network behaviours have to be hard-coded for each variable, introducing the possibility
for errors. In the BioModelAnalyzer tool [55], the JSON contains only the modi able parameters limiting
the possibility for error; the SBML-Qual standard achieves a similar goal for logical models [56].
Recommendation VII: Avoid creating new representations when common formats already exist. Use
existing extensible internationally standardised representations and formats to facilitate sharing and re-use.
2.8 World Records
The benchmarks the tool describes are fashioned only for this instance of this time. They might claim to
be from the Microsoft Windows device driver set, but the reality is that they are stripped down versions
of the originals. Stripped down so much as to be useless to anyone but the author vs. the referee. It is
worse than that really: enough benchmarks are included to beat other tools. The comparisons are never
fair (especially for comparisons against your tool). If every paper has to be novel, then every benchmark,
too, will be novel; there is no monotonic, historical truth in new, synthetically-crafted benchmarks. It is as
if, in order to beat Usain Bolt s 100m world record time, you make him race overweight and out of season,
with a winter overcoat and the wrong sized shoes. Given this setup, you could surely hope to beat his 9.58s
time on a shorter length track.
Recommendation VIII: Benchmarks should be public. They should allow anyone to contribute, imply-
ing that the tests are in a standard format. Further, these benchmarks must be heavily curated. Every
test/assertion should be justi ed. Papers should be penalised if they do not use these public benchmarks.
While there are some domains in which it may not be immediately possible to share full benchmarks sets,
this should be the exception (with justi cation) rather than the norm.
A good example of some of these points is the RCSB Protein Data Bank (http://www.pdb.org) and
Systems Biology Markup Language [56]. The software ones we know of, the SMT Competition (http:
5
//smtcomp.sourceforge.net/2014/), SV-COMP (http://sv-comp.sosy-lab.org/2015/) and Termination
Problems Data Base (http://termination-portal.org/wiki/TPDB) are on that journey. Such repositories
would allow the tests to be taken and easily analysed by any competitor tool. Some communities go
further; the Critical assessment of methods of protein structure prediction and prediction of interactions
(CASP and CAPRI)[57,58] communities present a single-blind test of protein folding and docking algorithms
annually, allowing open competition on a level playing  eld. Similarly the DREAM challenges (http:
//dreamchallenges.org/) attempt to address large scale problems through open competition.
2.9 Test It To See
Some models may be chaotic and in uenced by  oating-point errors (e.g. molecular dynamics), further
frustrating testing. For example: Sidekick is an automated tool for building molecular models and per-
forming simulations [59]. Each system is simulated from an di erent initial random seed, and under most
circumstances this is the only di erence expected between replicas. However, on a mixed cluster with both
AMD and Intel microprocessors on the nodes, the di erence in architecture was found to alter the number
of water molecules added to each system by one. This meant that the same simulation performed on dif-
ferent architectures would diverge. Similarly, in a di erent simulation engine, di erent neighbour searching
strategies gave divergent simulations due to the di ering order in which forces were summed.
A further example is the handling of pseudo-random number generation in Avida [60], an open source
scienti c software platform for conducting and analysing experiments with self-replicating and evolving com-
puter programs. While it may initially appear attractive to develop bespoke random number generators
within a system for consistency or performance across platforms, this invariably adds complexity to your
system and may inhibit sharing and reproducibility.
Recommendation IX: Despite these challenges to testing, unshared code is ultimately untestable. Testing
new complex scienti c software is di cult   until the software is complete, unit tests may not be available.
You should aim to re-use modules or repos (git submodules) from publicly-shared code; a corollary of Linus s
Law ( given enough eyeballs, all bugs are shallow ) might be that shared code is inherently more test-able.
2.10 Welcome to Web 2.0
Virtual machines (VMs) in the cloud also make the testing of scaling properties more simple. If you have a
tool that you claim is more e cient, you could put together a cluster of slow nodes in the cloud to demon-
strate how well the software scales for parallel calculations. Cloud computing is cheap, and getting cheaper.
Algorithms that used to require massive HPC resources can now be run cheaply by bidding on the VM spot
market. The web is a great leveller: use and share work ows and web services [61, 62].
Recommendation X: The web and the cloud really do open up a whole new way of working. Even
small, seemingly trivial features like putting up a web interface to your tool and its tests will allow users
who are not able to install necessary dependencies to explore the running of the tool [63]. Ultimately,
this can lead to making an  executable paper  appear on the Internet. The interactive Try F#(http:
//www.tryfsharp.org/Learn) and Z3 tutorials (http://rise4fun.com/Z3/tutorial/guide) are a great
start that begin to expose what can be done in this area.
3 A Model for Reproducible Research Software
Some of our Recommendations, such as  Be A Better Person  or  The Lingua Franca , are abstract, airy-
fairy, pie-in-the-sky even. However, most of them can be concretely realised by a service for reproducibility.
This service provides a concrete implementation of free source code ( Set The Code Free ) that depends
on other free source code ( Lineage ) building ( YMMV  ,  Welcome to Web 2.0  ) and running tests
contributed in public ( Data Representations ,  World Records ) in a completely reproducible regime.
The service we describe here can be seen as a speci cation. We have not built it, but many services like
travis-ci or Azure VSTS provide some of the mechanical parts of it. A service for reproducibility is intended
to play three important roles; it should:
i) Demonstrate that a piece of code can be compiled, run and behaves as described, without manual
intervention from the developer;
6
ii) Store and link speci c artefacts with their linked publications or other publicly-accessible datasets;
iii) Allow new benchmarks to be added, by users other than the developer, to widen the testing and identify
potential bugs.
The whole premise of our previous paper [40] is that algorithms (and their implementations) and models
(sometimes also called benchmarks) are inextricably linked. Algorithms are designed for certain types of
models; models, though created to mimic some physical reality, also serve to express the current known
algorithms. An integrated autonomous open cloud-based service can make this link explicit.
By developing a cloud-based, centralised service, which performs automated code compilation, testing
and benchmarking (with associated auditing), we will link together published implementations of algorithms
and input models. This will allow the prototype to link together software and data repositories, toolchains,
work ows and outputs, providing a seamless automated infrastructure for the veri cation and validation of
scienti c models and in particular, performance benchmarks. The program of work will lead the cultural
shift in both the short and long-term to move to a world in which computational reproducibility helps
researchers achieve their goals, rather than being perceived as an overhead.
A system as described here has several up-front bene ts: it links research papers more closely to their
outputs, making external validation easier and allows interested users to explore unaddressed sets of models.
Critically, it helps researchers across computational science to be more productive, rather than reproducib-
ility being an overhead on top of their day-to-day work. In the same way that tools such as GitHub make
collaborating easier while simultaneously allowing e ortless sharing, we envisage our system being simil-
arly usable for sharing and testing algorithms and their implementations, software, models and benchmarks
online.
Suppose you have come up with a better algorithm to deal with some standard problem. You write
up the paper on the algorithm, and you also push an implementation of your algorithm to the our cloud
environment s section on this standard problem. The e ect of pushing your implementation is to register
your program as a possible competitor in this standard problem competition. There exist several dozen
widely-agreed tests on this problem already on our cloud environment s database. Maybe, after some
negotiation due to your novel approach to this standard problem, you add some of your own tests to the
database too.
Pushing your code activates the environment s continuous integration system. The cloud pulls in all the
dependencies your code needs, on the platforms you specify, and runs all the benchmarks. This happens
every time you push. It also happens every time one of your dependencies (a library, a  rmware upgrade
for your platform, a new API) changes too. This system (presented in Figure 2) would integrate with
publicly available source code repositories, automates the build, testing and benchmarking of algorithms
and benchmarks.
It would allow testing models against competing algorithms, and the addition of new
models to the test suite (either manually or from existing online repositories).
Figure 2: Proposed reproducibility service work ow
If we are truly serious about addressing the systemic socio-technical issues in scienti c disciplines that
are underpinned by leveraging software and computational techniques, then the proposal above would bring
together almost all of the points we have discussed in this paper to provide an open research infrastructure
for all. There are already several web services that already aim to do many of these things [22,64], so a service
that can integrate most if not all of these features is possible. Such a service would then allow algorithms
and models to evolve together, and be reproducible from the outset. Something more open and complete,
7
and stamped with the authority of the major domain conferences/journals/national academies, would mean
that your code would never  bit-rot , and no one would have problems reproducing the implementation of
your published algorithm.
4 Next Steps
Following the proposal of such a system, the question becomes: how do we encourage widespread uptake,
or even standardisation? Such a service would appear to be non-trivial, given the large numbers of tools
and work ows that could potentially require to be supported by the service. After such a service has been
implemented, how do we ensure it is useful and usable for researchers. Furthermore, how do we make it
sustainable?
The bene ts to the wider computational research community from a cultural change to favour repro-
ducibility are clear and as such we should aim through software e-infrastructure and sharable, community
curated research work ows to mitigate these costs. Furthermore, we can reasonably expect the distinct
needs of speci c research communities to evolve over time, and initial implementations of the platform may
require re nement in response to user feedback (supporting the critical cultural change by improving the
e ciency of researchers). As such, if the wider research community is to move to requiring reproducibility,
it seems most reasonable that this is staggered over a number of years to allow for both of these elements
to develop, until eventually all researchers are required to use the service.
The key question for di erent research communities then becomes: how to initialise this change? Such
a requirement creates a set of new costs to researchers, both in terms of time spent ensuring that their tools
work on the centralised system (in addition to their local implementation), but also potentially in terms of
equipment (in terms of running the system). Such costs may be easier to bear for some groups compared
to others, especially those with large research groups who can more easily distribute the tasks, and it is
important that the service does not present a barrier to early career researchers and those with e cient
budgets (this type of cost analysis is not unique to reproducibility e orts   it has been estimated that a
shift to becoming exclusively open access for a journal may lead to a ten-fold increase in computer science
publication costs [65]).
Nevertheless, this proposed new e-infrastructure could have a profound impact on the way that compu-
tational science is performed, repositioning the role of models, algorithms and benchmarks and accelerating
the research cycle, perhaps truly enabling a  fourth paradigm  of data intensive scienti c discovery [66].
Ultimately though, continuing with an honest and open discussion of what reproducibility means for the
wider science research community is important: we all need to explicitly con rm that this is worthwhile and
commit to addressing it, or don t bother doing it at all.
A Note on Re-Writing the WSSSPE Paper
Many of the ideas, comments   even attitudes   in this paper come from the authors  experience in
programming, programming languages, software. We have started from the Marc Andreessen comment
that opens this paper. In editing this paper from its original WSSSPE workshop form, we realised that
one assumption that seems to run through the manuscript is that the behaviours we think are good are in
fact those that can be enforced in software. Take mutability of variables in programming as an example.
Mutability increases the scope for bugs, so modern programming languages like OCaml or C++14 enforce
immutability at the language or library level. But in fact immutability leads very naturally to state-less
or de novo build environments, and so to the guideline that  software must be compilable with de novo
continuous integration . And, similarly, so does the issue of openly publishing your toolchain: it too must
be compilable in a from-scratch build environment to be of use to anyone else.
References
[1] M. Andreessen,  Why Software Is Eating The World,  The Wall Street Journal, August 2011. Available
online: http://online.wsj.com/news/articles/SB10001424053111903480904576512250915629460.
[2] Royal Society,  Science as an open enterprise,  2012. Available from: https://royalsociety.org/
policy/projects/science-public-enterprise/report/.
8
[3] Editorial,  Devil in the details,  Nature, vol. 470, no. 7334, pp. 305 306, 2011.
[4] B. Alberts, R. J. Cicerone, S. E. Fienberg, A. Kamb, M. McNutt, R. M. Nerem, R. Schekman, R. Shif-
frin, V. Stodden, S. Suresh, M. T. Zuber, B. Kline Pope, and K. Jamieson,  Self-correction in science
at work,  Science, vol. 348, no. 6242, pp. 1420 1422, 2015.
[5] C. Collberg and T. A. Proebsting,  Repeatability in Computer Systems Research,  Communications
of the ACM, vol. 59, no. 3, pp. 62 69, 2016.
[6] T. Crick, M. De Vos, M. Brain, and J. Fitch,  Generating Optimal Code using Answer Set Pro-
gramming,  in Proceedings of 10th International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR 09), vol. 5753 of Lecture Notes in Computer Science, pp. 554 559, Springer, 2009.
[7] J. Berdine, B. Cook, and S. Ishtiaq,  SLAyer: Memory Safety for Systems-Level Code,  in Proceedings
of the 23rd International Conference on Computer Aided Veri cation (CAV 2011), vol. 6806 of Lecture
Notes in Computer Science, pp. 178 183, Springer, 2011.
[8] D. De Roure,  Replacing the Paper: The Twelve Rs of
the e-Research Record.  http:
//www.scilogs.com/eresearch/replacing-the-paper-the-twelve-rs-of-the-e-research-
record/, November 2011.
[9] V. Stodden, P. Guo, and Z. Ma,  Toward Reproducible Computational Research: An Empirical Analysis
of Data and Code Policy Adoption by Journals,  PLoS ONE, vol. 8, no. 6, 2013.
[10] G. Fursin and C. Dubach,  Community-Driven Reviewing and Validation of Publications,  in Proceed-
ings of the 1st ACM SIGPLAN Workshop on Reproducible Research Methodologies and New Publication
Models in Computer Engineering (TRUST 14), pp. 1 4, ACM Press, 2014.
[11] National Academies of Sciences, Engineering, and Medicine, Statistical Challenges in Assessing and
Fostering the Reproducibility of Scienti c Results: Summary of a Workshop. The National Academies
Press, 2016.
[12] S. Galiani, P. Gertler, and M. Romero,  Incentives for Replication in Economics,  tech. rep., National
Bureau of Economic Research, July 2017. NBER Working Paper No. 23576.
[13] N. Barnes,  Publish your computer code: it is good enough,  Nature, vol. 467, no. 753, 2010.
[14] A. Morin, J. Urban, P. D. Adams, I. Foster, A. Sali, D. Baker, and P. Sliz,  Shining Light into Black
Boxes,  Science, vol. 336, no. 6078, pp. 159 160, 2012.
[15] L. N. Joppa, G. McInerny, R. Harper, L. Salido, K. Takeda, K. O Hara, D. Gavaghan, and S. Emmott,
 Troubling Trends in Scienti c Software Use,  Science, vol. 340, no. 6134, pp. 814 815, 2013.
[16] S. Bechhofer, I. Buchan, D. De Roure, P. Missier, J. Ainsworth, J. Bhagata, P. Couch, D. Cruickshank,
M. Delder eld, I. Dunlop, M. Gamble, D. Michaelides, S. Owen, D. Newman, S. Su , and C. Goble,
 Why linked data is not enough for scientists,  Future Generation Computer Systems, vol. 29, no. 2,
pp. 599 611, 2013.
[17] L. Osherovich,  Hedging against academic risk,  Science-Business eXchange, vol. 4, no. 15, 2011.
[18] T. Hesman Saey,  Repeat Performance: Too many studies, when replicated, fail to pass muster, 
Science News, vol. 187, no. 2, pp. 21 26, 2015.
[19] C. Goble,  Better Software, Better Research,  IEEE Internet Computing, vol. 18, no. 5, pp. 4 8, 2014.
[20] F. Chirigati, M. Troyer, D. Shasha, and J. Freire,  A Computational Reproducibility Benchmark, 
IEEE Data Engineering Bulletin, vol. 36, no. 4, pp. 54 59, 2013.
[21] V. Stodden and S. Miguez,  Best Practices for Computational Science: Software Infrastructure and
Environments for Reproducible and Extensible Research,  Journal of Open Research Software, vol. 2,
no. 1, pp. 1 6, 2014.
9
[22] V. Stodden, S. Miguez, and J. Seiler,  ResearchCompendia.org: Cyberinfrastructure for Reproducibility
and Collaboration in Computational Science,  Computing in Science & Engineering, vol. 17, no. 12,
2015.
[23] V. Stodden, M. McNutt, D. H. Bailey, E. Deelman, Y. Gil, B. Hanson, M. A. Heroux, J. P. Ioannidis,
and M. Taufer,  Enhancing reproducibility for computational methods,  Science, vol. 354, no. 6317,
pp. 1240 1241, 2016.
[24] S. Fomel and J. F. Claerbout,  Reproducible Research,  Computing in Science & Engineering , vol. 11,
no. 1, 2008.
[25]  Reproducible Research,  Computing in Science & Engineering, vol. 12, no. 5, pp. 8 13, 2010.
[26] I. P. Gent,  The Recomputation Manifesto.  Available from: http://arxiv.org/abs/1304.3674, April
2013.
[27] G. Fursin, R. Miceli, A. Lokhmotov, M. Gerndt, M. Baboulin, A. D. Malony, Z. Chamski, D. Novillo,
and D. Del Vento,  Collective mind: Towards practical and collaborative auto-tuning,  Scienti c Pro-
gramming, vol. 22, no. 4, pp. 309 329, 2014.
[28] D. Bailey, J. Borwein, and V. Stodden,  Set the Default to  Open ,  Notices of the AMS, 2013.
[29] D. James, N. Wilkins-Diehr, V. Stodden, D. Colbry, C. Rosales, M. R. Fahey, J. Shi, R. F. da Silva,
K. Lee, R. Roskies, L. Loewe, S. Lindsey, R. Kooper, L. Barba, D. H. Bailey, J. M. Borwein,  O. Corcho,
E. Deelman, M. C. Dietze, B. Gilbert, J. Harkes, S. Keele, P. Kumar, J. Lee, E. Linke, R. Mar-
ciano, L. Marini, C. Mattmann, D. Mattson, K. McHenry, R. T. McLay, S. Miguez, B. S. Minsker,
M. S. P erez-Hern andez, D. Ryan, M. Rynge, I. S. P erez, M. Satyanarayanan, G. S. Clair, K. Webster,
E. Hovig, D. S. Katz, S. Kay, G. K. Sandve, D. Skinner, G. Allen, J. Cazes, K. W. Cho, J. Fonseca,
L. Hwang, L. Koesterke, P. Patel, L. Pouchard, E. Seidel, and I. Suriarachchi,  Standing Together for
Reproducibility in Large-Scale Computing: Report on reproducibility@XSEDE,  tech. rep., XSEDE,
2014.
[30] A. Prli c and J. B. Procter,  Ten Simple Rules for the Open Development of Scienti c Software,  PLoS
Computational Biology, vol. 8, no. 12, p. e1002802, 2012.
[31] H. Masum, A. Rao, B. M. Good, M. H. Todd, A. M. Edwards, L. Chan, B. A. Bunin, A. I. Su,
Z. Thomas, and P. E. Bourne,  Ten Simple Rules for Cultivating Open Science and Collaborative
R&D,  PLoS Computational Biology, vol. 9, no. 9, p. e1003244, 2013.
[32] G. Sandve, A. Nekrutenko, J. Taylor, and E. Hovig,  Ten Simple Rules for Reproducible Computational
Research,  PLoS Computational Biology, vol. 9, no. 10, p. e1003285, 2013.
[33] J. M. Osborne, M. O. Bernabeu, M. Bruna, B. Calderhead, J. Cooper, N. Dalchau, S.-J. Dunn, A. G.
Fletcher, R. Freeman, D. Groen, B. Knapp, G. J. McInerny, G. R. Mirams, J. Pitt-Francis, B. Sengupta,
D. W. Wright, C. A. Yates, D. J. Gavaghan, S. Emmott, and C. Deane,  Ten Simple Rules for E ective
Computational Research,  PLoS Computational Biology, vol. 10, no. 3, p. e1003506, 2013.
[34] A. Goodman, A. Pepe, A. W. Blocker, C. L. Borgman, K. Cranmer, M. Crosas, R. Di Stefano, Y. Gil,
P. Groth, M. Hedstrom, D. W. Hogg, V. Kashyap, A. Mahabal, A. Siemiginowska, and A. Slavkovic,
 Ten Simple Rules for the Care and Feeding of Scienti c Data,  PLoS Computational Biology, vol. 10,
no. 4, p. e1003542, 2014.
[35] N. P. Chue Hong, T. Crick, I. P. Gent, L. Kottho , and K. Takeda,  Top Tips to Make Your Research
Irreproducible,  2015. http://arxiv.org/abs/1504.00062.
[36] M. List, P. Ebert, and F. Albrecht,  Ten Simple Rules for Developing Usable Software in Computational
Biology,  PLoS Computational Biology, vol. 13, no. 1, p. e1005265, 2017.
[37] V. Stodden,  The Legal Framework for Reproducible Scienti c Research: Licensing and Copyright, 
Computing in Science & Engineering, vol. 11, no. 1, 2008.
[38] C. N. Haas,  Reproducible Risk Assessment,  Risk Analysis, vol. 36, no. 10, pp. 1829 1833, 2016.
10
[39] T. Crick, B. A. Hall, and S. Ishtiaq,   Can I Implement Your Algorithm? : A Model for Reproducible
Research Software,  in 2nd International Workshop on Sustainable Software for Science: Practice and
Experiences (WSSSPE2), 2014.
[40] T. Crick, B. A. Hall, S. Ishtiaq, and K. Takeda,   Share and Enjoy : Publishing Useful (and Usable)
Scienti c Models,  in Proceedings of the 7th IEEE/ACM International Conference on Utility and Cloud
Computing, pp. 957 961, 2014.
[41] R. M. Stallman, Free Software Free Society: Selected Essays of Richard M. Stallman. Free Software
Foundation, 2010.
[42] J. Giles,  Software company bans competitive users,  Nature, vol. 429, no. 6989, 2004.
[43] B. Hess, C. Kutzner, D. van der Spoel, and E. Lindahl,  GROMACS 4: Algorithms for Highly E cient,
Load-Balanced, and Scalable Molecular Simulation,  Journal of Chemical Theory and Computation,
vol. 4, no. 3, pp. 435 447, 2008.
[44] B. R. Brooks, C. L. Brooks, A. D. Mackerell, L. Nilsson, R. J. Petrella, B. Roux, Y. Won, G. Archontis,
C. Bartels, S. Boresch, A. Ca isch, L. Caves, Q. Cui, A. R. Dinner, M. Feig, S. Fischer, J. Gao,
M. Hodoscek, W. Im, K. Kuczera, T. Lazaridis, J. Ma, V. Ovchinnikov, E. Paci, R. W. Pastor, C. B.
Post, J. Z. Pu, M. Schaefer, B. Tidor, R. M. Venable, H. L. Woodcock, X. Wu, W. Yang, D. M.
York, and M. Karplus,  CHARMM: The biomolecular simulation program,  Journal of Computational
Chemistry, vol. 30, no. 10, pp. 1545 1614, 2009.
[45] K. J. Bowers, E. Chow, H. Xu, R. O. Dror, M. P. Eastwood, B. A. Gregersen, J. L. Klepeis, I. Ko-
lossvary, M. A. Moraes, F. D. Sacerdoti, J. K. Salmon, Y. Shan, and D. E. Shaw,  Scalable algorithms
for molecular dynamics simulations on commodity clusters,  in Proceedings of the 2006 ACM/IEEE
Conference on Supercomputing, IEEE Press, 2006.
[46] L. de Moura,  Releasing the Z3 source code,  2012. Available online: http://leodemoura.github.io/
blog/2012/10/02/open-z3.html.
[47]  Open Source Licenses.  http://opensource.org/licenses.
[48] G. Wilson,  Software carpentry: Getting scientists to write better code by making them more product-
ive,  Computing in Science & Engineering, vol. 8, no. 6, 2006.
[49] G. Gonthier, B. Ziliani, A. Nanevski, and D. Dreyer,  How to make ad hoc proof automation less ad
hoc,  Journal of Functional Programming, vol. 23, no. 4, pp. 357 401, 2013.
[50] G. Miller,  A Scientist s Nightmare: Software Problem Leads to Five Retractions,  Science, vol. 314,
no. 5807, pp. 1856 1857, 2006.
[51] A. M. Smith, D. S. Katz, K. E. Niemeyer, and the FORCE11 Software Citation Working Group,
 Software Citation Principles,  PeerJ Computer Science, vol. 2, no. e86, 2016.
[52] C. Boettiger,  An introduction to Docker for reproducible research,  ACM SIGOPS Operating Systems
Review, vol. 49, no. 1, pp. 71 79, 2015. Special Issue on Repeatability and Sharing of Experimental
Artifacts.
[53] S. A. Kau man,  Metabolic stability and epigenesis in randomly constructed genetic nets,  Journal of
Theoretical Biology, vol. 22, no. 3, pp. 437 67, 1969.
[54] M. A. Schaub, T. A. Henzinger, and J. Fisher,  Qualitative networks: a symbolic approach to analyze
biological signaling networks,  BMC Systems Biology, vol. 1, p. 4, 2007.
[55] D. Benque, S. Bourton, C. Cockerton, B. Cook, J. Fisher, S. Ishtiaq, N. Piterman, A. Taylor, and M. Y.
Vardi,  BMA: visual tool for modeling and analyzing biological networks,  in Proceedings of the 24th
International Conference on Computer Aided Veri cation (CAV 2012), vol. 7358 of Lecture Notes in
Computer Science, pp. 686 692, Springer, 2012.
11
[56] C. Chaouiya, D. Berenguier, S. M. Keating, A. Naldi, M. P. van Iersel, N. Rodriguez, A. Drager,
F. Buchel, T. Cokelaer, B. Kowal, B. Wicks, E. Goncalves, J. Dorier, M. Page, P. T. Monteiro, A. von
Kamp, I. Xenarios, H. de Jong, M. Hucka, S. Klamt, D. Thie ry, N. Le Novere, J. Saez-Rodriguez,
and T. Helikar,  SBML qualitative models: a model representation format and infrastructure to foster
interactions between qualitative modelling formalisms and tools,  BMC Systems Biology, vol. 7, 2013.
[57] J. Moult, K. Fidelis, A. Kryshtafovych, T. Schwede, and A. Tramontano,  Critical assessment of
methods of protein structure prediction (CASP)   round x,  Proteins: Structure, Function, and
Bioinformatics, vol. 82, pp. 1 6, 2014.
[58] M. F. Lensink, S. Velankar, and S. J. Wodak,  Modeling proteinprotein and proteinpeptide complexes:
Capri 6th edition,  Proteins: Structure, Function, and Bioinformatics, vol. 85, no. 3, pp. 359 377,
2017.
[59] B. A. Hall, K. B. A. Halim, A. Buyan, B. Emmanouil, and M. S. P. Sansom,  Sidekick for membrane
simulations: Automated ensemble molecular dynamics simulations of transmembrane helices,  Journal
of Chemical Theory and Computation, vol. 10, no. 5, pp. 2165 2175, 2014.
[60] C. Ofria and C. O. Wilke,  Avida: A Software Platform for Research in Computational Evolutionary
Biology,  Arti cial Life, vol. 10, no. 2, pp. 191 229, 2004.
[61] T. Crick, P. Dunning, H. Kim, and J. Padget,  Engineering Design Optimization using Services and
Work ows,  Philosophical Transactions of the Royal Society A, vol. 367, no. 1898, pp. 2741 2751, 2009.
[62] S. Olabarriaga, G. Pierantoni, G. Ta oni, E. Sciacca, M. Jaghoori, V. Korkhov, G. Castelli, C. Vuerli,
U. Becciani, E. Carley, and B. Bentley,  Scienti c Work ow Management   For Whom?,  in Proceedings
of 10th IEEE International Conference on e-Science (e-Science 2014), pp. 298 305, IEEE Press, 2014.
[63] B. A. Hall, E. Jackson, A. Hajnal, and J. Fisher,  Logic programming to predict cell fate patterns and
retrodict genotypes in organogenesis,  Journal of The Royal Society Interface, vol. 11, no. 98, 2014.
[64] N. D. Rollins, C. M. Barton, S. Bergin, M. A. Janssen, and A. Lee,  A Computational Model Library for
publishing model documentation and code,  Environmental Modelling & Software, vol. 61, pp. 59 64,
2014.
[65] M. Y. Vardi,  Openism, IPism, Fundamentalism, and Pragmatism,  Communications of the ACM,
vol. 57, no. 8, 2014.
[66] T. Hey, S. Tansley, and K. Tolle, eds., The Fourth Paradigm: Data-Intensive Scienti c Discovery.
Microsoft Research, 2009.
12
