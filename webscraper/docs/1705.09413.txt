Learnable Programming: Blocks and Beyond

David Bau
MIT CSAIL

Cambridge, MA USA

davidbau@csail.mit.edu

Jeff Gray

Dept. of Computer Science

University of Alabama
Tuscaloosa, AL USA
gray@cs.ua.edu

Caitlin Kelleher

Dept. of Computer Science

Washington University

St. Louis, MO USA

ckelleher@cse.wustl.edu

7
1
0
2

 

y
a
M
6
2

 

 
 
]
L
P
.
s
c
[
 
 

1
v
3
1
4
9
0

.

5
0
7
1
:
v
i
X
r
a

Josh Sheldon

MIT CSAIL

Cambridge, MA USA

jsheldon@csail.mit.edu

Franklyn Turbak

Computer Science Dept.

Wellesley College
Wellesley, MA, USA

fturbak@cs.wellesley.edu

ABSTRACT
Blocks-based programming has become the lingua franca for
introductory coding. Studies have found that experience with
blocks-based programming can help beginners learn more
traditional text-based languages. We explore how blocks
environments improve learnability for novices by 1) favoring
recognition over recall, 2) reducing cognitive load, and 3)
preventing errors.
Increased usability of blocks program-
ming has led to widespread adoption within introductory
programming contexts across a range of ages. Ongoing work
explores further reducing barriers to programming, support-
ing novice programmers in expanding their programming
skills, and transitioning to textual programming. New blocks
frameworks are making it easier to access a variety of APIs
through blocks environments, opening the doors to a greater
diversity of programming domains and supporting greater
experimentation for novices and professionals alike.

Keywords
Blocks-based programming interfaces; Computing education

1.

INTRODUCTION

A global push to broaden participation in computer science
has led to an explosion of interest in blocks-based program-
ming. Visual blocks are used by more than a dozen pro-
gramming tools (see the Sidebar below). Millions of students
receive their ﬁrst exposure to programming via these tools in
courses and activities like Code.org’s Hour of Code. Blocks
allow beginners to compose programs without struggling
with the frustrations of syntax (Figure 1).

There is increasing interest in developing and studying
blocks languages. At VL/HCC 2015, a small workshop

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from permissions@acm.org.

To appear in Communications of the ACM, June 2017, pp. 72-80.
c(cid:13)2017 ACM

Figure 1: Snap! is an example of a blocks-based
programming environment. Users drag blocks from
a palette of programming elements (left) into a
workspace (center), where blocks can be assembled
into programs. Snap! also provides an output win-
dow (top-right) and a sprite picker (bottom-right).

session called Blocks and Beyond 1 ballooned to a large event,
with 51 submissions and 36 presenters. Researchers shared
work in new blocks languages, interface innovations, domain-
speciﬁc applications of blocks, and ways to make blocks
languages more eﬀective and accessible for diverse coders.

This article explores how blocks impact the learnability
of programming. We begin by reviewing studies on the
eﬀectiveness of blocks languages. Then we discuss the key
features of blocks languages and how they relate to learning.
Finally, we look at applications of blocks in new domains
and discuss tools for creating your own blocks language.

2. DO BLOCKS LANGUAGES WORK?

Watching beginners create their ﬁrst programs with blocks
can be simultaneously inspiring and unsettling. Empowered
by blocks, novices will rapidly build complex, often delightful
creations. But just as quickly, they ﬁll their screen with
clumsy and intricate code [22]. A seasoned programmer
inspecting a beginner’s disordered assembly might worry
that snapping together colorful blocks has nothing to do with
“real code.” But what is “real code,” and why learn it?

1http://cs.wellesley.edu/blocks-and-beyond

2.1 What is “Real Code?”

The purpose of a blocks-based tool is to make programming
easy to learn. But programming education can have two
distinct endpoints:

1. Development of expertise in professional programming.

2. Ability to accomplish other goals by creating programs.

The two objectives are not necessarily the same. The
designers of Scratch note that for users “who see programming
as a medium for expression, not a path toward a career,
Scratch is suﬃcient for their needs” [28]. The GP blocks
environment is being designed to enable “casual programmers”
to create ever more sophisticated programs, while removing
limits that would force them to switch away from blocks [24].
Before discussing the learning eﬀects of blocks-based pro-
gramming, we begin with a caution that it would be short-
sighted to assume that tomorrow’s programmers will program
with the same languages and systems as today’s. Each gen-
eration of programmers shifts the culture of coding, and the
deﬁnition of “real code” will continue to evolve.

However, core learning questions remain. For students who
continue with the study of traditional programming, we can
ask if a blocks-based introduction to programming is helpful
or not. This question has been directly tested in classrooms.
2.2 Measuring Learning Transfer

Research indicates that learning a blocks language can
improve later learning of a traditional textual language. In a
study of 10th graders learning C# or Java [1], those who had
taken a Scratch course in 9th grade learned more quickly, un-
derstood loops better, and were more engaged and conﬁdent
than their peers who had not. However, in the ﬁnal test, a
signiﬁcant diﬀerence was seen in only one of three cognitive
dimensions. In a study at two colleges [25], students with
little or no previous programming experience and weak math
preparation completed a CS0 programing class using Alice
before beginning a Java CS1 course. Starting with Alice im-
proved student grades (GPA of 3.0 versus 1.2 for non-Alice
students) and the percentage of students taking further CS
courses (88% compared to 47%).

The question of whether such eﬀects are simply due to
giving students more preparation in an extra class has been
tested by creating courses that combine a blocks-based intro-
duction with a transition to a traditional language. Reports
from courses using Scratch before Java or C indicate improved
student engagement and understanding of some concepts [19,
39]. In one study focused on learning transfer [8], an intro-
ductory Java course at CMU was modiﬁed to begin with
Alice. Students in this class that used both languages aver-
aged 10% or more better performance on every section of
the same Java ﬁnal exam, including expression evaluation,
control structures, arrays, and working with class deﬁnitions.
That result is remarkable because one might assume that
spending more time programming with blocks meant less
time to learn Java. The study used a version of Alice that gen-
erated Java code from Alice blocks, and a mediated transfer
pedagogy that made explicit connections between program-
ming concepts in Alice and Java.

Other studies of CS1 courses that switch from blocks to text
without these features have identiﬁed potential challenges
to learning with blocks [10, 27]. Switching from a blocks
language to text can involve both a change in syntax and

semantics, and Shapiro and Ahrens propose teaching the
transitions separately, teaching syntax before generalizing
semantics [32]. Additional research is needed to identify the
circumstances under which blocks are eﬀective.

Today, many introductory computer science courses use
a blocks-before-text approach. In Harvard’s CS50, students
move from Scratch to C; Berkeley’s CS10 progresses from
Snap! to Python; Project Lead The Way’s Computer Science
Principles (CSP) course uses both Scratch and App Inventor
before moving on to Python; and Code.org’s CSP App Lab
course moves from Droplet blocks to JavaScript.

3. WHY BLOCKS ARE LEARNABLE

In 2004, Ko, Myers and Aung [15] identiﬁed six learning
barriers encountered by non-programmers in programming
tasks. Three of these — selection, use, and coordination —
reﬂect the diﬃculty of simply assembling a program.

We believe the learnability of blocks languages arises from
how they address the usability challenges underlying these
three learning barriers:

1. Learning a programming vocabulary is hard. Blocks
simplify this problem because picking a block from a
palette is far easier than remembering a word: blocks
rely on recognition instead of recall.

2. Code is hard to use because it presents a high cognitive
load for new programmers. Blocks reduce the cogni-
tive load by chunking code into a smaller number of
meaningful elements.

3. Assembling code is error-prone. Blocks help users as-
semble code without basic errors by providing con-
strained direct manipulation of structure (e.g., two
incompatible concepts do not have connecting parts).

3.1 Recognition versus Recall

Programming with a simple language or library typically
involves a vocabulary of about 100-200 words. For example,
HTML has 100 tags and 100 attributes, and SQL has about
200 keywords; Scratch is similar, with 130 blocks. Recalling
100-200 concepts can overwhelm a newcomer.

Unlike text languages, blocks languages are intimately tied
to their programming environments, and nearly all block
environments have adopted a few interface conventions that
address key usability problems. One such convention is tack-
ling vocabulary by organizing blocks in functionally related
palettes on the screen.

Palettes diﬀer from autocomplete menus in professional
code editors because they persist instead of disappearing and
they organize concepts by topic instead of by name. This
design simpliﬁes discovery and exploration. Figure 2a shows
the Sound palette in Scratch. It is an instructive reference
showing all 13 methods for audio in that environment.

Similar organization is seen in larger blocks environments.
To help manage the complexity of creating mobile apps, App
Inventor provides a dynamic set of blocks, with additional
blocks available in programs that have interactions with more
components (Figure 2b). Yet, the basic idiom is the same as
Scratch: explorable palettes organized by function.

Remembering the order, type, and valid values of operands
is also daunting for newcomers. Many systems address this
by supplying blocks with default operand values, drop-down

playNoteFor(60, 0.5)

(a) Scratch

(b) Python

Figure 3: Blocks show structure visually instead of
using punctuation. They can aid learnability using
plain language, default values, and value pickers.

(a) Scratch

(b) App Inventor

Figure 2: The sound palette in Scratch and a voice
synthesis palette in App Inventor. Palettes simplify
the selection of programming elements by exploiting
the ease of recognition over recall. Palettes organize
concepts by topic, not name, and they remain open
when used, allowing the user to discover and tinker
with blocks based on their function.

menus and specialized editors to specify operands, and extra
words to indicate operand meanings (Figure 3a).
3.2 Chunking Information with Blocks

Programming languages present a high cognitive load to a
student who is learning a new syntax. For example, consider
the for loop in JavaScript syntax:

for (var i = 0; i < 50; i++) { ··· }

This dense notation is a barrier to beginners. In the words
of one student, JavaScript “is really confusing to understand
with all the parentheses and brackets and all of that” [38].

To understand the diﬃculty, consider that this code con-
tains ﬁve words (for var i i i), ten pieces of punctuation
(( = ; < ; + + ) { } ), and two numbers (0 and 50), a
total of seventeen units of information. Studies of human
cognitive capacity have established that people have a work-
ing memory of about seven chunks of information [23]. Trying
to understand this line of code as seventeen separate items
may overwhelm the working memory of a new programmer.
Experienced JavaScript programmers have no problem
understanding the line of code above because they have
learned to interpret the code in larger chunks. Because a for
loop follows a very common pattern, it can be read in just two
chunks: ﬁrst, the typical for loop that uses the conventional
looping pattern (i starting at 0 and incrementing by 1);
second, the particular choice of 50 as the upper limit. Figure
4 illustrates diﬀerent ways of chunking the code.

Blocks help reduce cognitive load by showing new program-
mers how to read larger chunks. In the Code.org Computer
Science Principles course, blocks for JavaScript for loops are
drawn just as an expert would see the code: as two chunks

Figure 4: Three ways of reading a for loop in chunks.
A naive reading of code (top) interprets the code
as 17 chunks, but an expert reading of code (mid-
dle) interprets the most common form of loop as
a single chunk, with a second chunk for the loop
limit 50. An alternative (bottom) reading interprets
three clauses as chunks. Code.org uses the middle
rendering when introducing loops to high-school stu-
dents for the ﬁrst time, and switches to the bottom
rendering when students are familiar with for loops.

with a single block with a single socket for the loop upper
bound. Complexity can also be reduced by nesting chunks
within chunks. For example, Code.org reveals ﬁner-grained
for structure in more advanced portions of the same course,
as illustrated at the bottom of Figure 4.

The use of blocks to chunk code aids readability even for
simple commands, because blocks can forgo the punctuation
that text code uses to denote structure and use explanatory
words instead. For example, as illustrated in Figure 3b, a
simple call in Python requires reading delimiters and knowing
argument order, whereas the equivalent block in Scratch reads
naturally, using plain words to explain its behavior.

By organizing code as visible chunks, blocks help new
programmers concentrate on what the code means rather
than the notation that is used to write it.
3.3 Direct Manipulation of Visible Structure
The visual form of blocks alleviates the burden of assem-
bling syntactically correct units by typing one character at a
time. But there are other advantages of directly manipulating
program fragments that have visual constraints.

One beneﬁt is that the blocks can help prevent errors by
making the grammar of a program visible. Blocks can be seen
as a form of syntax-directed editing with constrained direct
manipulation. In 1981, creators of an early structured-editing
tool noted, “Programs are not text; they are hierarchical com-
positions of computational structures and should be edited,
executed, and debugged in an environment that consistently
acknowledges and reinforces this viewpoint” [35].

Block shapes help beginners understand which grammat-
ical phrases (expresssions vs. commands vs. declarations)

Figure 5: Block shapes show and enforce rules of
composition. Scratch commands compose vertically,
and expressions ﬁt into holes. Here, a Boolean ex-
pression (diamond shape) is being dropped into a
matching hole for a loop test condition.

are legal in what contexts. In Scratch, commands connect
vertically with nubs and notches, whereas expressions are
smooth shapes that ﬁt into smooth holes. Constraints on
drag-and-drop prevent the two types from being confused
(Figure 5). Students report that the puzzle shapes are helpful
for assembling programs [38].

Visualization of types by shape can be applied to richer
type systems: OpenBlocks provides 14 connector shapes to
represent diﬀerent types [29], and researchers have created
experimental block languages with dynamically generated
shapes to represent compositional type systems [18, 36].

Directly manipulable blocks also encourage bottom-up
tinkering with program pieces in ways not directly supported
by raw text. Blocks programmers experiment with blocks
by connecting them to build islands of code fragments on
the programming surface that are isolated from the main
program [22, 38]. In blocks environments supporting liveness
[20], these fragments can be executed by pointing and clicking,
providing a key beneﬁt of interpreted text-based languages
without a read-eval-print loop console separate from the
editor. The program gradually grows as it is augmented by
dropping in these fragments when they behave as desired.
3.4 Learnability Beyond Blocks

Blocks aid in the construction of code, but blocks alone
are not enough to make a programming language learnable.
Users new to a language face additional learning challenges:
• They must wrestle with practical aspects like installing

language tools, saving/loading programs, etc.;

• They must learn the vocabulary of the language and

understand the concepts denoted by its words;

• They need to understand runtime semantics such as

ﬂow of control and changes in state over time;

• They eventually need to learn common patterns of use,

moving beyond isolated concepts.

Each of these learning hurdles can be helped or hindered by
the programming environment, and each of these problems
is an area of active research and development.
3.4.1 Programming Online
To simplify installation, programming tools are moving on-
line. When a programming environment is in a web browser,
a new programmer is just a few clicks away from creating a
ﬁrst program. A cloud-based programming tool can provide

a complete and consistent programming environment with
fewer potential problems.

Although blocks programming environments for beginners
have long been oﬀered online, text-based programming envi-
ronments are also becoming available online. With tools such
as Cloud 9, CodeAnywhere, and CodeEnvy, programmers of
all levels can beneﬁt from working online.

3.4.2 Words, Concepts, and Abstractions
The names chosen for language constructs can have an im-
pact on learnability. Empirical studies by Steﬁk and Seibert
[34] have found that common keywords like for or operators
such as != serve as hard-to-learn jargon, and are not as easily
learnable as familiar words such as repeat or unequal. They
found that the syntax of languages such as Java and Perl are
no more learnable than a synthetic programming language
with randomly-selected punctuation used for keywords.

Even more important for learnability are the abstractions
chosen by language designers to allow users to build sim-
ple programs with compelling behavior. For example, the
designers of Alice worked with users to develop intuitive
abstractions for controlling 3D animations. During their
design process, the Alice team eliminated jargon such as
transformation matrices and substituted more intuitive con-
cepts like object-relative motions. These new abstractions
made it easier for users to specify 3D animations [7].

Designing languages and libraries focused on learnability
based on empirical evidence is a major area for future work.

3.4.3 Runtime Understanding
The dynamic state of a program can be made more under-
standable by making its state visible. For example, Code.org
highlights the individual block that is actively running so the
correspondence between code and action can be seen. Snap!
provides widgets for every variable to show the current state.
Even with highly visible state, understanding actions in
the past or future can be diﬃcult. Liveness [20] is one
approach to addressing this problem. A live system aims to
make actions concrete by applying them immediately to the
current state. For example, in App Inventor, Scratch, and
Snap!, many edits to a running block program take eﬀect
immediately, without the need to restart the program.

Another approach for making the evolution of state under-
standable is to allow the programmer to travel in time by
inspecting, advancing or rewinding the timeline of a program.
The concept of omniscient debugging was ﬁrst described in
the early 1970s as a capability to trace backward in time
through execution history to identify the location of the fault
that caused a later observed failure [40]. TRAKLA2 [26],
UUhistle [33] and Online Python Tutor [12] provide this
capability for Java and Python.

3.4.4 Examples and Reuse
The activity of programming has changed with the avail-
ability of large repositories containing examples of shared
code. Programmers of all levels report ﬁnding and adapting
examples as a core programming activity [6, 9]. In response,
professional programming and end-user programming en-
vironments are beginning to incorporate example support
[5, 31]. Novices, too, want to learn via examples, but may
struggle to do so [30]

Blocks-based languages like Scratch and Looking Glass use
online sharing and remixing programs to provide example

Figure 6: Greenfoot’s Stride editor combines text-
style editing for expression-level details with drag-
and-drop blocks for higher-level program structure.

access. But there is a tradeoﬀ between the simplicity of reuse
and the robustness of reused code. For example, Scratch
simpliﬁes sharing of code examples for novices by providing
a “backpack” for collecting program snippets and assets that
can be shared and dragged into a new project. However, the
backpack does not necessarily guarantee that the code will
run correctly in a new project.

In contrast, Looking Glass uses a more complex process for
reuse in which users select the beginning and end of behavior
they want to use. Coupled with execution history informa-
tion, this can ensure that the selected code will function
within the context of a new program. A Play & Explore
feature allows users to connect program output to the line
or lines of code that caused it, helping users to understand
and begin to modify reused code.

4. SCALING BLOCKS CODE

Why don’t professionals program with block interfaces?
One reason is that direct manipulation has eﬃciency dis-
advantages when making small edits. When creating an
expression such as (a/2 + b/2) in blocks, the programmer
must ﬁnd and drag blocks for each of the three arithmetic
operators, and then ﬁll in holes with variables and numbers.
Similarly, when rearranging an expression from (a/2+b/2) to
(a+b)/2, the expression tree needs to be pulled apart and put
together again, requiring more gestures and more forethought
than making the edits in text. HCI researchers observed that
visual programming languages can have a higher viscosity
than text code because they make small changes harder [11].
Beyond viscosity, blocks environments can have several
other usability disadvantages compared to textual program-
ming languages:

• Low density: blocks take more space on the screen than

equivalent text code.

• Search and navigation: it can be challenging to ﬁnd
and navigate to the relevant part of a blocks program
in a 2D workspace, only part of which may be visible.
• Source control: collaboration and version control sys-
tems are diﬃcult to use without a text representation.

The newest generation of blocks programming tools include
features that are designed to resolve the tension between

Figure 7: Pencil Code provides bidirectional switch-
ing between blocks and text. Mode switching allows
users to learn with blocks and edit quickly with text.

usability advantages of text versus blocks. There are two ap-
proaches: text-style entry and bidirectional mode switching.
4.1 Text-Style Entry of Blocks

Some new blocks environments, such as Greenfoot’s frame-
based Stride editor [16] and GP [24], are designed to be used
by programmers to create large programs, so eﬃcient editing
is an important design goal.

Both Stride and GP improve eﬃciency by providing text-
based editing shortcuts within a blocks-oriented interface.
To allow users to circumvent the step of ﬁnding a block
on the palette, these systems let programmers enter blocks
through an in-line autocomplete mechanism. Blocks can still
be chosen from a palette, but a knowledgeable programmer
can insert them by typing.

The Stride editor also introduces a hybrid approach to
editing code, diﬀerentiating between low-level and high-level
structure (Figure 6). For expression-level code, it hides syn-
tactic structure and allows traditional text editing, providing
high-density display and lower viscosity. Visible tree struc-
ture and drag-and-drop manipulation are used for higher-level
code such as control ﬂow and class declarations.
4.2 Bidirectional Mode Switching

Some blocks environments provide a bidirectional transfor-
mation between a traditional text language and a blocks rep-
resentation of that language. These include Pencil Code (Cof-
fee Script) [2] (Figure 7), Code.org’s App Lab2 (JavaScript),
BlockEditor (Java) [21], and Tiled Grace (Grace) [13]. Alice
and Blockly provide non-editable views of text code.

The hypothesis that motivates the design of dual-mode
tools is that users may beneﬁt from the learnability of blocks
in one mode, while they learn syntax and get the eﬃciency
of text in the other mode. This goal requires that the views
be linked. For text to be safe for users who may want to
return to blocks, it must be possible to return to blocks.

In dual-mode editors, the text code is the primary repre-
sentation of the program, and blocks are a projected user
interface view derived by parsing. This approach allows the
editor to fully represent text information such as spacing,
but it also means that the editor must allow syntax errors
that would not have been possible in blocks. Error-recovery
heuristics convert simple text syntax errors to special error
blocks, but complex errors can prevent mode switching.
4.3 Comparing Approaches

There is a tradeoﬀ between the two approaches to unifying
blocks and text. While the dual-mode editors provide direct
support for learning traditional text syntax such as JavaScript

2https://code.org/educate/applab

Figure 8: Blocks programming in MadeUp.
3D
printing is an area of rapid innovation, and blocks
make it possible to use new 3D modeling languages
without a steep learning curve.

or Java, they also impose the cognitive overhead of working
with syntax errors that that can only be introduced in text
mode. Visualization research on multiple coordinated views
suggests that the beneﬁts of providing more than one view
need to be balanced against the cognitive overhead imposed
by switching between views [37].

Single mode structured editors have the advantage of a
conceptual model free of syntax errors, because the primary
object being edited is the abstract syntax tree. However, to
maintain consistency, many kinds of textual edits must be
prevented, and other edits may require special tree editing
commands. These constraints raise editing viscosity, and
they may present additional cognitive barriers.

Interfaces that eﬀectively bridge the gap between blocks

and text are an active area of research.

5. APPLYING BLOCKS: TWO EXAMPLES
Let us take a look at experimental blocks languages in two
speciﬁc domains that are unfamiliar to most programmers.
5.1 Programming 3D Printers

Traditionally, 3D printing models are drawn interactively
by direct manipulation using CAD software. Writing custom
code to create a model is a powerful alternative approach,
but coding for 3D fabrication has traditionally been the
province of a few expert programmers. Now, the falling cost
and rising availability of 3D printers has made it possible for
non-specialists to write their own custom 3D modeling code.
Two recently developed languages bring programming for
3D printing to novice users: BeetleBlocks [17] and Madeup
[14]. Although the two systems have diﬀerent languages,
there are several commonalities: both are web-based inter-
faces with a live 3D rendering of the shape being created, and
both provide a blocks language to simplify learning. Beetle-
Blocks follows the principles of turtle graphics: a beetle
moves a “pen” that can be turned on and oﬀ, and 3D shapes
can be created out of iterated strokes. MadeUp (Figure 8)
takes a more abstract approach, allowing users to trace out
both paths and parametric surfaces. Special functions can
rotate or extrude the paths to create solids.

The two languages oﬀer diﬀerent levels of power and ab-
straction. Which language is the right one to use? This

Figure 9: The SPARQL Playground is a blocks-
based query execution tool that provides blocks for
constructing queries of RDF data. Query results
(bottom) are also provided as blocks, and they can
be dragged to build into other queries.

domain is an excellent example of the advantage of the learn-
ability of blocks. Both blocks languages have a very shallow
learning curve, and it is easy to try both.
5.2 Querying the Semantic Web

Another domain where learnability is essential is in query-
ing large datasets. Consider the problem of querying Re-
source Description Framework (RDF) data from the seman-
tic web. SPARQL is the standard language for querying
RDF; it includes several constructs for working with RDF
triples that distinguish it from other query languages such as
SQL. However, potential users of SPARQL face two hurdles:
First, programmers must learn the vocabulary and syntax
of SPARQL, with its specialized operators and constructs.
Second, querying RDF requires not just knowledge of the
language, but also knowledge of instance and schema data.
To address both problems, Paolo Bottoni and Miguel Ce-
riani have created a blocks language they call the SPARQL
Playground [4]. Rather than helping users learn about se-
quential programs, their blocks language helps users select,
ﬁlter, and join data using SPARQL primitives.

The SPARQL playground is interesting for a second rea-
son: all query results in the playground are also returned as
draggable blocks (Figure 9). This feature allows users to save
instance data on the programming workspace to be incorpo-
rated into new queries. With the SPARQL playground, it is
easy to begin with general queries to explore the types of data
available, then use these discoveries to make reﬁnements.

6. MAKING NEW BLOCKS LANGUAGES
It is now possible to create your own domain-speciﬁc blocks
environment using a blocks-based language toolkit. Blocks-
language authors should be aware of at least three toolkits:
Blockly3, Droplet [3], and OpenBlocks [29].

The original blocks metalanguage is MIT OpenBlocks.
Created in 2007 by Ricarose Roque as the basis of StarLogo
TNG, it allows a large degree of geometric customization.
OpenBlocks has also been used in App Inventor Classic and
BlockEditor. One drawback of OpenBlocks is that it requires
users to download and install the Java JDK.

3https://developers.google.com/blockly

fromhttp://dbpedia.org/sparqlwhereorder by↓ ▾& limit to first5rows↪obj ▾dbpedia:Paul_McCartneydbpedia:George_Harrisondbpedia:John_Lennondbpedia:Ringo_Starrobj ▾━┫┣━▶dbo:formerBandMemberis a  &dbr:The_BeatlesThe challenge of installation is addressed by Blockly, an
HTML-based block language toolkit by Neil Fraser of Google.
Blockly is currently the most popular blocks language toolkit:
it is the tool behind App Inventor, the SPARQL playground,
and MadeUp, as well as the Code.org Hour of Code puzzles.
Future versions of Scratch will also use Blockly.

Droplet is the newest of the blocks language creation toolk-
its, developed by Anthony Bau for use in Pencil Code, and
also used by Code.org in their App Lab. It is newer and less
mature than OpenBlocks and Blockly, but takes a unique
approach that allows seamless bidirectional transformation
between all blocks and textual code.

7. SUMMARY

When a programming language is provided as a user inter-
face that welcomes novice users, rather than as a technical
tool only for experienced developers, we arrive at a new
picture of what the programming environment should do:

• Vocabulary should derive from recognition, not recall;
• Cognitive load should be lowered by chunking code;
• Grammar rules and types should be made visible;
• Program chunks should be directly manipulable;
• Low-viscosity editing should also be possible;
• Coding should work without installation of tools;
• Simple concepts should be described with clear words

and high-level abstractions;

• Runtime state and behavior should be visible;
• Examples should be easy to ﬁnd and apply.

In short, for a programming tool to be usable by new or
casual programmers, its design must focus on learnability.

Blocks have proven to be eﬀective at solving many of these
problems. Although programming is still not nearly as widely
learned as it should be, the progress made by blocks language
interfaces can inspire us all to see that programming can be
made more learnable.

The art of programming is the original human-computer
interaction, and it remains an unsolved usability challenge.
We can still do more to make programming available to all.

8. REFERENCES
[1] M. Armoni, O. Meerbaum-Salant, and M. Ben-Ari.

From Scratch to “real” programming. Transactions on
Computing Education, 14(4), Feb. 2015.

[2] D. Bau, D. A. Bau, M. Dawson, and C. S. Pickens.

Pencil Code: Block code for a text world. In 14th
International Conference on Interaction Design and
Children, pages 445–448, 2015.

[3] D. A. Bau. Droplet, a blocks-based editor for text code.

Journal of Computing Sciences in Colleges,
30(6):138–144, June 2015.

[4] P. Bottoni and M. Ceriani. Using blocks to get more
blocks: Exploring linked data through integration of
queries and result sets in block programming. In IEEE
Blocks and Beyond Workshop, pages 99–102, Oct. 2015.

[5] J. Brandt, M. Dontcheva, M. Weskamp, and S. R.

Klemmer. Example-centric programming: Integrating
web search into the development environment. In ACM
SIGCHI Conference on Human Factors in Computing
Systems, CHI ’10, pages 513–522, 2010.

[6] J. Brandt, P. J. Guo, J. Lewenstein, M. Dontcheva, and

S. R. Klemmer. Two studies of opportunistic
programming: Interleaving web foraging, learning, and
writing code. In ACM SIGCHI Conference on Human
Factors in Computing Systems, CHI ’09, pages
1589–1598, 2009.

[7] M. Conway, S. Audia, T. Burnette, D. Cosgrove, and

K. Christiansen. Alice: Lessons learned from building a
3D system for novices. In ACM SIGCHI Conference on
Human Factors in Computing Systems, CHI ’00, pages
486–493, 2000.

[8] W. Dann, D. Cosgrove, D. Slater, D. Culyba, and

S. Cooper. Mediated transfer: Alice 3 to Java. In 43rd
ACM Technical Symposium on Computer Science
Education, SIGCSE ’12, pages 141–146, 2012.

[9] B. Dorn and M. Guzdial. Graphic designers who

program as informal computer science learners. In
Second International Workshop on Computing
Education Research, ICER ’06, pages 127–134, 2006.
[10] R. Garlick and E. C. Cankaya. Using Alice in CS1: a

quantitative experiment. In 15th Annual Conference on
Innovation and Technology in Computer Science
Education, ITiCSE ’10, pages 165–168, 2010.

[11] T. R. G. Green. Cognitive dimensions of notations. In

A. Sutcliﬀe and L. Macaulay, editors, People and
Computers V, pages 443–460. Cambridge University
Press, Cambridge, UK, 1989.

[12] P. J. Guo. Online Python tutor: Embeddable

web-based program visualization for CS education. In
44th ACM Technical Symposium on Computer Science
Education, SIGCSE ’13, pages 579–584, 2013.

[13] M. Homer and J. Noble. Combining tiled and textual

views of code. In 2014 Second IEEE Working
Conference on Software Visualization, VISSOFT ’14,
pages 1–10, Sept 2014.

[14] C. Johnson and P. Bui. Blocks in, blocks out: A

language for 3D models. In IEEE Blocks and Beyond
Workshop, pages 77–82, Oct. 2015.

[15] A. J. Ko, B. A. Myers, and H. H. Aung. Six learning
barriers in end-user programming systems. In IEEE
Symposium on Visual Languages and Human Centric
Computing, VL/HCC ’04, pages 199–206, 2004.
[16] M. K¨olling, N. C. C. Brown, and A. Altadmri.

Frame-based editing: Easing the transition from blocks
to text-based programming. In 10th Workshop in
Primary and Secondary Computing Education,
WiPSCE ’15, Nov. 2015.

[17] D. Koschitz and E. Rosenbaum. Exploring algorithmic

geometry with “Beetle Blocks:” a graphical
programming language for generating 3d forms. In 15th
International Conference on Geometry and Graphics,
pages 380–389, Aug. 2012.

[18] S. Lerner, S. R. Foster, and W. G. Griswold.

Polymorphic blocks: Formalism-inspired UI for
structured connectors. In 33rd Annual ACM
Conference on Human Factors in Computing Systems,
CHI ’15, pages 3063–3072, 2015.

[19] D. J. Malan and H. H. Leitner. Scratch for budding

computer scientists. ACM SIGCSE Bulletin,
39(1):223–227, Mar. 2007.

[20] J. H. Maloney and R. B. Smith. Directness and liveness
in the morphic user interface construction environment.

In 8th Annual ACM Symposium on User Interface and
Software Technology, pages 21–28, 1995.

[21] Y. Matsuzawa, T. Ohata, M. Sugiura, and S. Sakai.

Language migration in non-CS introductory
programming through mutual language translation
environment. In 46th ACM Technical Symposium on
Computer Science Education, SIGCSE ’15, pages
185–190, 2015.

[22] O. Meerbaum-Salant, M. Armoni, and M. Ben-Ari.
Habits of programming in Scratch. In 16th Annual
Joint Conference on Innovation and Technology in
Computer Science Education, ITiCSE ’11, pages
168–172, 2011.

[23] G. A. Miller. The magical number seven, plus or minus

two: some limits on our capacity for processing
information. Psychological Review, 63(2):81, 1956.

[24] J. M¨onig, Y. Ohshima, and J. Maloney. Blocks at your
ﬁngertips: Blurring the line between blocks and text in
GP. In IEEE Blocks and Beyond Workshop, pages
51–53, Oct. 2015.

[25] B. Moskal, D. Lurie, and S. Cooper. Evaluating the
eﬀectiveness of a new instructional approach. ACM
SIGCSE Bulletin, 36(1):75–79, 2004.

[26] J. Nikander, A. Korhonen, O. Sepp¨al¨a, V. Karavirta,

P. Silvasti, and L. Malmi. Visual algorithm simulation
exercise system with automatic assessment: Trakla2.
Informatics in Education-An International Journal,
3(2):267–288, 2004.

[27] K. Powers, S. Ecott, and L. M. Hirshﬁeld. Through the
looking glass: Teaching CS0 with Alice. ACM SIGCSE
Bulletin, 39(1):213–217, Mar. 2007.

[28] M. Resnick, J. Maloney, A. Monroy-Hern´andez,
N. Rusk, E. Eastmond, K. Brennan, A. Millner,
E. Rosenbaum, J. Silver, B. Silverman, and Y. B. Kafai.
Scratch: programming for all. Communications of the
ACM, 52(11):60–67, 2009.

[29] R. Roque. Openblocks: An extendable framework for

graphical block programming systems. Master’s thesis,
MIT, May 2007.

[30] M. B. Rosson, J. Ballin, and H. Nash. Everyday
programming: Challenges and opportunities for
informal web development. In 2004 IEEE Symposium
on Visual Languages and Human Centric Computing,
VL/HCC’04, pages 123–130, Sept 2004.

[31] N. Sawadsky and G. C. Murphy. Fishtail: From task
context to source code examples. In 1st Workshop on
Developing Tools As Plug-ins, pages 48–51, 2011.

[32] R. B. Shapiro and M. Ahrens. Beyond blocks: Syntax

and semantics. Communications of the ACM,
59(5):39–41, 2016.

[33] J. Sorva and T. Sirki¨a. Context-sensitive guidance in

the UUhistle program visualization system. In
Proceedings of the 6th Program Visualization Workshop,
pages 77–85, 2011.

[34] A. Steﬁk and S. Siebert. An empirical investigation into

programming language syntax. Transactions on
Computing Education, 13(4):19:1–19:40, Nov. 2013.
[35] T. Teitelbaum and T. Reps. The Cornell program

synthesizer: A syntax-directed programming
environment. Communications of the ACM,
24(9):563–573, 1981.

[36] M. Vasek. Representing expressive types in blocks

programming languages. Undergraduate thesis,
Wellesley College, May, 2012.

[37] M. Q. Wang Baldonado, A. Woodruﬀ, and

A. Kuchinsky. Guidelines for using multiple views in
information visualization. In Proceedings of the
Working Conference on Advanced Visual Interfaces,
pages 110–119, 2000.

[38] D. Weintrop and U. Wilensky. To block or not to block,

that is the question: students’ perceptions of
blocks-based programming. In 14th International
Conference on Interaction Design and Children, pages
199–208, 2015.

[39] U. Wolz, H. H. Leitner, D. J. Malan, and J. Maloney.
Starting with Scratch in CS1. ACM SIGCSE Bulletin,
41(1):2–3, Mar. 2009.

[40] M. Zelkowitz. Reversible execution. Communications of

the ACM, 16(9):566, 1973.
APPENDIX: SIDEBAR
Blocks-Based Educational Tools
On the web:

puzzle programming exercises with tutorial videos

tion and game creation, with support for extensions

• Scratch (https://scratch.mit.edu) - in-browser anima-
• Code.org (http://code.org) - a variety of tools including
• Snap! (http://snap.berkeley.edu) - enhanced language
inspired by Scratch that includes ﬁrst class functions
• App Inventor (http://appinventor.mit.edu) - creation
• Pencil Code (https://pencilcode.net) - creates Coﬀee-
Script web apps, transforming between text and blocks
• StarLogo Nova (http://www.slnova.org) - multi-agent
• Blockly Games (https://blockly-games.appspot.com/) -
• GameBlox (https://gameblox.org) - game creation that

a set of puzzles to solve with programming blocks

simulations and games in a 3D rendered world

of Android apps using in-browser blocks IDE

includes clonable agents, physics, and more

Downloadable:

• AgentSheets / AgentCubes (http://www.agentsheets.com)

- pioneering blocks environments for creating rule-based
games and simulations
• Alice (http://www.alice.org) - pioneering blocks envi-
ronment for creating 3D virtual worlds; support for
exporting to Java
• Looking Glass (https://lookingglass.wustl.edu) - 3D
animated story creation; supports independent learning
• Kodu (http://www.kodugamelab.com) - rule-based pro-

gramming of games for xBox and PC

On mobile:

of animated scenes aimed at preliterate children

• Scratch Jr (http://www.scratchjr.org) - programming
• Pocket Code (http://www.catrobat.org) - blocks pro-
• Tynker (https://www.tynker.com) - polished commer-
• Hopscotch (https://www.gethopscotch.com) - creating

gramming for small form factor of mobile devices

cial platform for game and animation creation

games and animations on iPhone and iPad

