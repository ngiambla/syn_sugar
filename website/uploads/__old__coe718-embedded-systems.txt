COE718 - EMBEDDED SYSTEMS DESIGN

THE IMPLEMENTATION OF A MEDIA

CENTER WITH THE M3 CORTEX

October 26, 2017

Nicholas V. Giamblanco
Student ID: 500551269

Ryerson University

Department of Computer and Electrical Engineering

Contents

II

Abstract
I

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.I
Why Use An Embedded System? . . . . . . . . . . . . . . . . . . . . . .
Previous Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I/O with Keil’s MCB1700 . . . . . . . . . . . . . . . . . . . . . . . . . .
II.I
Hardware Software Interfacing . . . . . . . . . . . . . . . . . . . . . . .
II.II
II.III
Threads/Processes/Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . .
III Methodology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Terminal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.I
Context Switching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.II
IV.III Music Player: Musik . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.IV Photo gallery: Foto Gallery . . . . . . . . . . . . . . . . . . . . . . . . .
IV.V Game: Snake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.VI Screen Saver . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.VII Password Generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.VIII System Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
V
VI Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Appendix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
usbmain.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Terminal.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
PasswordGen.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
snake.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Retarget.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Main.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3
4
4
4
5
5
5
6
6
6
7
8
9
9
11
11
11
11
14
15
16
16
22
23
23
31
34

1

Giamblanco, N.

Ryerson University

Getline.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ScreenSaver.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

40
43

Page 2 of 49

Giamblanco, N.

ABSTRACT

Ryerson University

This report explores the use of an Embedded System to create a Media Center for consumer enjoyment.
Speciﬁcally a Media Center was successfully implemented with the Keil MCB1700 Board and the NXP
LPC1768 ARM Cortex-M3 Processing Unit and met the following requirements:

• A Photo Gallery

• An "mP3 Player"

• Game(s)

• Extra Functionality (If Provided)

The Keil µVision 4 IDE (Integrated Development Environment) was used for the implementation of this
project.

Page 3 of 49

Giamblanco, N.

I

INTRODUCTION

Modern-day computing has impacted many aspects
of society, from ease of access to information,
to convenience for shopping, to medical advance-
ments. However, the term computing is general.
Many electronic devices that consumers use day-
to-day are not general purpose units. In fact, many
of these devices are Embedded Systems. Embed-
ded systems are usually electronic devices designed
for speciﬁc purposes, and operate with schedul-
ing desires in mind. Examples of Embedded Sys-
tems/Devices are: a programmable thermostat, IoT
Devices, Cellular Devices, etc. Many of these de-
vices have constraints such as, battery power con-
sumption, performance considerations, optimiza-
tion consideration. The hardware and associated
software are designed in order to meet the special-
ized need. This report outlines the design and im-
plementation of a Media Center on an embedded
system. Speciﬁcally, this lab explores an imple-
mentation of an embedded system that meets the
following speciﬁcations:

• A Photo Gallery

• An mP3 Player (simulated through USB

streaming)

Ryerson University

In order to understand why a Media Center was
implemented on an Embedded System, an investi-
gation into Embedded Systems must take place.

I.I Why Use An Embedded Sys-

tem?

Embedded Systems are systems designed for a spe-
ciﬁc purpose. Generally, embedded systems are
required for low power devices, real-time deadlines,
and portable application. Any Smart Phone is a
great example and demonstration of this. Smart
Phones require low power consumption since they
are battery powered. User that use Smart Phones
would preferably enjoy all day battery life for day-
to-day activities. These devices meet real-time dead-
lines. Set an alarm on any Smart Phone. At the time
you have set, you should see that an alarm sounds.
This is a real-time deadline, for if the alarm was
late, or early, the deadline was effectively missed.
It must sound at the correct time. Smart Phones are
also portable. The objective of this project was to
create a Media Center.

• A Command Line Interface (Similar to a

II PREVIOUS WORK

UNIX environment)

• A Screen Saver

• A Game (The Snake Game)

• A Password Generator

• Keyboard Compatibility Feature

• System Settings Feature

This project was part of the course COE718 - Em-
bedded Systems Design, where the hardware used
in this project was explored in several experiments
during the duration of this course. Speciﬁcally, we
explored several techniques that are unique to em-
bedded systems (speciﬁcally ARM devices), and
considerations for optimal operation. These experi-
ments provided a fundamental base to work with.

Page 4 of 49

Giamblanco, N.

Ryerson University

II.I

I/O with Keil’s MCB1700

II.II Hardware Software Interfac-

Many of the experiments required in the class
COE718 provided a method to understand how to
output data with the MCB1700 Board. Speciﬁcally,
the following was investigated:

1. The use of the joystick:

• The source code for the use of the joy-
stick was provided by the many of the
experiments, and a full understand of
the API was required. Functions such
as KBD_Init() and get_button() pro-
vided the majority of the functionality
for the joystick.

2. The use of the on board LED’s:

• The source code which interfaced with
the MCB1700’s on board LED’s pro-
vided an appropriate API for integration
of this code. This was not used in this
project.

3. The use of the LCD Display:

• A in-depth understand of the LCD was
required when creating this project,
as most project components needed
Functions such
to be displayed.
as
GLCD_Init(),
GLCD_Clear(),
GLCD_DisplayString(),
GLCD_SetTextColor(),
GLCD_Bitmap() were utilized heavily.
However, COE718’s previous exper-
iments provided enough information
for proper and efﬁcient use of this
functions.

ing

One unique feature provided with the hardware ex-
plored in this course was Bit Banding. This feature
eliminates inefﬁciencies in port communications.
Speciﬁcally, bit banding provides a unique address
to a target port, which eliminates the use of bit
masking, be it an AND mask or OR mask. Although
this feature was not utilized in this project, it is a
notable feature of this ARM processor. We also in-
vestigated other properties of the Thumb-2 ISA, and
code optimization that takes place on compilation.

II.III Threads/Processes/Tasks

Embedded Systems are important devices that meet
specialized tasks. A Smart Phone is a very complex
machine and is an example of an embedded system.
It has the capability to host an Operating System. It
responds to incoming text messages or phone calls.
It has connectivity to the Internet. It can provide
you with alarms, reminders, etc. Although some of
these features are available to most general comput-
ing systems, receiving/making phone calls/texts is a
special feature which is handled by the design of the
embedded system. Picture the following situation:
a user on their Smart Phone is using an app they
had downloaded. Picture any application. A few
seconds later, the user gets notiﬁed of an incoming
phone call. Their application is now interrupted by
this call. It turns out to be a very important call, and
the user accepts the incoming call. The user starts to
communicate on the call. This examples the use of
multitasking in embedded systems. Although this
example does not reﬂect normal embedded system
multitasking (which is generally real-time), it does
provide a general discussion to it. In order for a

Page 5 of 49

Giamblanco, N.

Ryerson University

Smart Phone to receive or send a phone call, there
is a task which provides the logic and functionality
to do so. However many other activities on a Smart
Phone exist, and are scheduled as other tasks. The
illusion of these activities running at the same time
takes place because of a multitasking. By execut-
ing segments of a task at in schedule fashion for
all scheduled tasks, multitasking is realized. These
tasks can take form as processes or threads (which
behave similarly from a top-level view). Unfortu-
nately, no Thread or Tasks were implemented in this
project as it adds extra and unnecessary complexity.

Figure 1: The Top Level View of Program Opera-
tion

III METHODOLOGY

Figure 2: Technical View of Software Design

Efﬁciency, Modularity, Compact-ability, and Perfor-
mance are all to be considered when designing any
system, be it from a software point of view, or to the
layout of roads, highways, etc. In this project, the
design of a ﬂexible and efﬁcient software system
was necessary. This design required the deﬁnition
of the project in terms of objects, functions, and
logic. All required functionality was implemented
as individual functions, some of which were deﬁned
in various ﬁles, (i.e filename.c, filename.h), or
some of which existed in the main program code
of this project. These functions were linked to the
main program code, where all functions could be
executed, and then return back to a stable operating
state. It is important to note that only one function
can be executed at a time. Therefore, implementa-
tion of multitasking was not necessary.

This software design provides ﬂexibility in many
areas and reduces code complexity. It takes the
shape of the Simpleton Software Design Pattern.

IV DESIGN

The design can only be processed once the most
effective methodology was formulated. For this
project, the following design mirrored a UNIX en-
vironment, with a CLI. That is, this project is a Me-
dia Center and behaves in a way similar to a Bash
(Bourne Again SHell) Terminal. This way, the user
is provided easy access to the required functional-
ity. It also provided a unique way of capturing user
input, allowing more options for functional applica-
tions. During the remainder of this discussion, this
project will be referred to Mbed OS.

IV.I The Terminal

The terminal was constructed from the required
application requirements. Therefore, for each ap-
plication, there was a command associated with it.
This provided the means for ﬂexible ease of access.
For example, if an application by the name of Foto

Page 6 of 49

Giamblanco, N.

Ryerson University

const char menu[] =

----+ DESC --------------

"\n"
"########################################\n"
"# Mbed OS - v1.1
#\n"
"# A UNIX Style Operating Sys.
#\n"
"########################################\n"
#\n"
"# CMND
| Goes to Foto Menu
"# [f]
#\n"
| Goes to the Game Menu. #\n"
"# [p]
#\n"
| Puts System to Sleep
"# [s]
"# [m]
| Shows Musik Menu
#\n"
#\n"
| Sys Settings.
"# [-]
#\n"
| Clears Screen.
"# [c]
#\n"
| Password Generator.
"# [z]
"# [h]
| Displays this.
#\n"
"########################################\n";

Figure 3: Mbed OS’s CLI Option Menu

Gallery was available in this software, you could
perhaps indicate to the user to input ’f’ to execute
this particular application. This not only provides
ﬂexibility to both the system designer, and user, but
it also provides a familiar feel to UNIX users.

In order to capture any input from the user
through the use of a keyboard, an exploration of
drivers, and source code for interfacing is required.
Luckily, Keil provided several example projects in
which a keyboard was interfaced. After exploration
and "reverse-engineering" of these projects, and
referencing the MCB1700 speciﬁcation provided
by Keil, the integration of the Keyboard was possi-
ble. Speciﬁcally, the terminal interface was made
possible by several facts:

1. The Keyboard Connection must be established

ﬁrst through use of

usbh_init(0); /*Initialize USB Host
/* allow kbd connect detect
for (i = 0; i < 1000000; i++) {

*/

*/

usbh_engine(0);
if (usbh_hid_status(0, 0)) /* if connected, break*/

break;

}

2. Once Connected, polling the keyboard
for input
If no keys are
pressed with the keyboard the function
usbh_hid_kbd_getkey(0, 0) returns a value

is required.

of −1. The use of polling is an undesirable
feature, as it wastes CPU time. Interrupt based
operation would be ideal as it favours CPU uti-
lization across a software system. However,
this system required a point of execution, in
which all applications can be executed from,
and then return back to this point. Therefore,
an inﬁnite loop was created in order provide
this functionality. Inside this loop, a check for
user input was completed.

As in most modern day computing systems,
the redirection from the Keyboard (Standard
Input) to the Terminal (Standard Out) must
take place. Therefore, an exploration and mod-
iﬁcation of this behavior on the MCB1700 is
a must. In the ﬁle Redirect.c, STDIO deﬁ-
nitions are created. This allows the function
getline() to redirect the keys pressed from
the keyboard to the on-board LCD display (the
terminal).

IV.II Context Switching

It may be convenient to deﬁne the idea of a context:
a context is a functional program requirement (an
application within the software system) a user inter-
acts with. In order to switch between the required
contexts, a method of input is required. In this case,
a user inputs a command with the use of the key-
board and the context is switched accordingly. If no
command is recognized, than no execution/context
switching will take place. This is easily accom-
plished by polling for commands, or inputs, and
creating a switch() software structure to deduce
what the user has input. This is how all the applica-
tions in this software system proceed to execute, or
return from execution.

Page 7 of 49

Giamblanco, N.

Ryerson University

IV.III Music Player: Musik

The music player, as per the application require-
ments, only implements a streaming USB connec-
tion, in which a host operating system sets up a
device driver and sends a bit stream. This stream
is then converted at the device receiver into digital
values, and is then converted to an Analog Wave-
form. This takes place in the form of an interrupt.
Speciﬁcally, a buffer is ﬁlled up with the incoming
transmission data. This data is then processed with
an interrupt service return (ISR). In order to execute
the interrupt service return, a periodic timer is set
with period T . With any music application, volume
is a concern that must be addressed. In this project,
an on board potentiometer was used to control this
feature. Within the ISR, the volume was checked
against a reference value, and the corresponding
analog waveform could be ampliﬁed or diminished.

/******************************************
* Timer Counter 0 Interrupt Service Routine
executed each 31.25us (32kHz frequency)
*
*******************************************/

void TIMER0_IRQHandler(void)
{
...
...
...

if (DataRun && run==0) {
/* Data Stream is running */

val = DataBuf[DataOut];
/* Get Audio Sample */
cnt = (DataIn - DataOut) & (B_S - 1);
/* Buffer Data Count */
if (cnt == (B_S - P_C*P_S)) {
/* Too much Data in Buffer */
DataOut++; /* Skip one Sample */

}
if (cnt > (P_C*P_S)) { /* Still enough Data in Buffer */

DataOut++; /* Update Data Out Index */

}
DataOut &= B_S - 1; /* Adjust Buffer Out Index */
if (val < 0) VUM -= val; /* Accumulate Neg Value */
else VUM += val; /* Accumulate Pos Value */
val
val >>= 16; /* Adjust Value */
val += 0x8000;
/* Add Bias */
val &= 0xFFFF; /* Mask Value */

/* Apply Volume Level */

*= Volume;

} else {

val = 0x8000;

/* DAC Middle Point */

}

...
...
...

/* Set Speaker Output */
if ((Tick++ & 0x03FF) == 0) {
/* On every 1024th Tick */

get_potval();
/* Get Potenciometer Value */
if (VolCur == 0x8000) {
/* Check for Minimum Level */

Volume = 0;
/* No Sound */

} else {

Volume = VolCur * PotVal;
/* Chained Volume Level */

}
val = VUM >> 20;
/* Scale Accumulated Value */
VUM = 0;
/* Clear VUM */
if (val > 7) val = 7;
/* Limit Value */

}

LPC_TIM0->IR = 1; /* Clear Interrupt Flag */
}

It is important to note, that a USB connection must
be set up prior to data streaming. The Keil board
will be conﬁgured as a device, and the host OS
(Operating System) as the operating system. This
is a problem that was experience in this design,
where the device could not be conﬁgured simul-
taneously as Host and Device.
In order to uti-
lize the keyboard, the Keil board had to be set
up to act as a host. And to stream music from
a host, the project had to be conﬁgured as a de-
vice. Therefore, the music player application was
a standalone application that could run on a de-
vice conﬁgured board. With this being said, an-
other issue presented itself. This application entered
an inﬁnite loop (in order to be in the operational
state always), and could not be broken out of origi-
nally. To patch this ﬂaw (as a user should be able to
start/stop streaming music, and connect/disconnect
from the host system), USB_Connect(TRUE) or
USB_Connect(FALSE) was called in order to stop
the streaming service. Then,
the
application could reset the system by using the
NVIC_SystemReset() or by adding a return to the
ISR, causing the inﬁnite loop to break, and return to
the original application. Since this application was

if required,

Page 8 of 49

Giamblanco, N.

Ryerson University

standalone, there was no point of execution to return
to, and therefore neither the NVIC_SystemReset()
or the return was implemented. This particular im-
plementation did demonstrate the ability to start and
stop streaming, and play and ’pause’ music.

suddenly head west, this is not permitted in this
implementation. Therefore, the user will lose.

In order to implement this game within the
C language, the following methodology proved
useful:

IV.IV Photo gallery: Foto Gallery

A very important application of the this software
system was the photo gallery (which was named
Foto Gallery for creative purposes). By indicating
the command ’f’, a context switch occurs, and a
loop occurs, which displays images. Before the im-
ages are display-able, the images must be converted
in a character array, with their color description per
pixel described by 3 or 4 bytes. Once the image was
successfully converted, displaying it was possible
through the function GLCD_Bitmap(). This func-
tion took arguments of where to center the image in
terms of a horizontal and vertical component, how
large was the image, and the contents of the image.
The importance of this application provide extra
knowledge on how to apply images to a graphical
game.

IV.V Game: Snake

The game that was implemented on this device was
snake. Snake has the following objectives:

A snake is in a ﬁeld. In this ﬁeld, food randomly
appears for the snake. The snake is hungry and
needs to eat the food. By eating the food however,
the snake grows. The snake must eat as much food
as it can before the length of the snake is too large
and the snake eats itself.

As well, the snake can only move in its current
direction, or perpendicular to its direction. This
means that if a snake is headed east, and wants to

init();
while alive do

draw();
caught=detectCollisions();
updateLocation();
if caught then

displayHighScore();
alive=dead;

end

end

Algorithm 1: Snake Game Logic

To understand the program logic of the game,
a brief description of each listed method in this
algorithm is required:

– init()

This method provides the logic for clearing
any existing game data (which may exist due
to previous plays from the user, or other users.)
This also provides the initial randomized lo-
cation of the snake food, as well as the de-
terministic initial location of the snake head.
This also stores the current users name (deter-
mined from Keyboard Input). A list of ﬁve
recent users, and their scores are kept as a
scoreboard for comparison.

– draw()

In order to display the a graphical represen-
tation of the game, pictures (originally .png
ﬁles) of the snake body, and the snake food
were converted into the C code equivalent.

Page 9 of 49

Giamblanco, N.

Ryerson University

The background of the playing ﬁeld was kept
black, which was done with purpose. When
displaying images on the LCD display, a dy-
namic image (something that changes) does
not automatically reﬂect with this change. In
practice, the old copy of the image is dis-
played, as well as the changed copy of the
image. This provides an inaccurate displaying
mechanism. In order to combat this problem,
a copy of the image was created and modiﬁed
such that the only color in this copy was black.
Therefore, the logic became as follows: draw
over the existing images with their black equiv-
alents at the location prior to location change
using GLCD_Bitmap(), then update the loca-
tion, and ﬁnally, redraw the original image
versions at the new location. This provided
the illusion that the image was moving.

It is crucial to understand that the snake, which
consists of a dynamic body, requires extra
logic in the draw() method. That is, based
of the length of the body, each of the existing
pieces of the body must also update their rel-
ative location in relation to the head and user
input. However, if a snake has a length of size
n then the i th body piece must replace its loca-
tion with the body piece located at (i−1). This
occurs for all body pieces in snake, excluding
the head (which accepts the new location input
by the user).

– detectCollisions() In this game, only two
types of collisions are possible: a collision
with food (which the snake apparently eats),
and a collision with itself. In either case, these
collisions can be detected using rectangular
collision algorithms (as both the snake body
and food are rectangular).

The general logic is as follows:

if (obj1.x < obj2.x + obj2.width &&

obj1.x + obj1.width > obj2.x &&
obj1.y < obj2.y + obj2.height &&
obj1.height + obj1.y > obj2.y) {

// collision detected!

}

Clearly, if a collision is detected with itself,
the end of game ensues, as the user lost the
game. A ﬂag is set, allowing the game to stop
execution in safe manner.

If a collision with a food item is detected, the
corresponding food item is removed (by draw-
ing over the food item with its black counter-
part), the snake is able to grow by one body
piece, and the score is incremented.

Otherwise, this will do nothing.

– updateLocation()

order

to

the

update

the
provides

location,
In
user
updateLocation()
to enter a new direction from the keyboard
input: W, A, S, D, where the direction provided
is up,
left, down, and right, respectively.
A user should not be required to hold the
keys in order to maintain direction. Instead,
pressing anyone of these keys sets a ﬂag
which permits continuous movement in the
speciﬁed direction, until the ﬂag is then again
updated.

This function returns a status in the main loop
of the game, in which will allow inﬁnite exe-
cution, or break the loop if the user has lost
the game.

– displayHighScore()

Once the user has lost, the current user score
is added to a range of 5 user scores and titles,
and displayed as output. This is displayed

Page 10 of 49

Giamblanco, N.

Ryerson University

until the [ESC] key is pressed. This returns
from the game to the main point of execution.

IV.VI Screen Saver

Since this system provides a similar appearance to
a UNIX based system with graphical options, al-
lowing the user to put the system to sleep seemed
reasonable, such that a screen saver would be dis-
played at the sleep time. The command ’s’ would
begin execution of this application. During this
time, the character $ was displayed at randomized
location between the bounds of the screen. The
colour of the this character was also cycled through
all colours available to this LCD, which provide a
eye pleasing look. This took place inside an inﬁnite
loop, based off keyboard polling. Since the key-
board generates the integer value signal of -1 when
no key is pressed, the inﬁnite loop will remain run-
ning from this fact, and stop otherwise. This means
the application could be stopped at absolutely any
time by pressing any key on the keyboard. This
would return back to the main point of execution.

IV.VII Password Generator

This application had a ﬁnite running time, where
an eight character long password was generated, in
hopes of being cryptographically secure. In general,
the idea of generating a password can be imple-
mented with the bitwise XOR operation. Then, using
the MOD operator, the range of applicable numbers
can be truncated at some maximum. The overall
process is as follows:

for i in range (0, 8):

produce random value in range of ASCII

for j in range (0, L)

XOR characters with random values and MOD in range of ASCII.

IV.VIII System Settings

For user preferences, systems settings were pro-
vided to modify the background and text colour
uniquely, and maintain these values for the whole
session the user is active.

In order to reﬂect these colours within the entire
session, a global variable either had to be set, or
a private variable had to be set and return from
external function. The latter was used in this lab,
where colours where updated to a private variable
in another C ﬁle, and then called upon during when
clearing the LCD screen or changing text colour.
The list of colours applicable for each menu option
were

char colour_menu[]=

|" "[2] - Navy\n"

"[1] - Black
"[3] - Dark Green |" "[4] - Dark Cyan\n"
"[5] - Maroon
"[7] - Olive
"[9] - Blue
"[b] - Cyan
"[d] - Magenta

|" "[6] - Purple\n"
|" "[8] - Dark Grey\n"
|" "[a] - Green\n"
|" "[c] - Red\n"
|" "[e] - Yellow\n";

V RESULTS

Through the methodology outlined in this report,
and the Simpleton software design, all application
requirements were completed successfully. That
being said, several hardship were encountered:

– Since this project utilized keyboard operation,
USB streaming could not take place, and there-
fore a standalone application solely for audio
streaming was created.

– Ensuring Game Play was smooth and consist
was a major consideration, and therefore much
time went into planning effective code to re-
duce complexity and increase performance.

Page 11 of 49

Giamblanco, N.

Ryerson University

– Extra Features were added in order to add a
familiar UNIX environment feeling, as well
as typical user request functions that aid in
productivity, etc.

Figure 6: System Settings Prompt.

Here, the successful operation of the system set-
tings has been demonstrated. This feature was an
extra. It was executed after the interpreter received
the [-] command.

Figure 4: Changing of the background to Yellow.

Figure 7: Password Generator.

Figure 5: Changing of the Text to Blue.

This clearly demonstrates the successful opera-
tion of the password generator after the user entered
the command [z]

Page 12 of 49

Giamblanco, N.

Ryerson University

saver, which can be Interrupted by the keyboard by
pressing any key.

Figure 8: Terminal Prompt and Interface.

Figure 10: Displaying the Logo of Mr. Robot (The
television series)

By pressing [h] or on program start-up, the user is
brought this prompt. It outlines all options available
on this board.

Figure 11: Displaying the Apple Logo

Figure 9: Screen Saver Display

Here is an example of another extra feature which
is implemented successfully. This is the screen

The implementation of the photo gallery was

successful.

Page 13 of 49

Giamblanco, N.

Ryerson University

issues could be overcome. This project was a suc-
cess in creating a Media Center, and exploring an
Embedded System.

Figure 12: The execution of the snake game.

The requirement to implement a game was com-
pleted successfully through the implementation of
Snake.

VI CONCLUSION

In conclusion, this project accomplished two very
important items. Firstly, the application require-
ments for the Media Center were successfully im-
plemented. All requirements were met, and in some
cases, exceeded the expectation. This means that
the photo gallery, the music player, and the game
were created with a main point of execution (the
Mbed OS Terminal) and were reliable. Finally, this
project provided practical experience by allowing a
real world application to be implemented, with an
item used in today’s ever changing technological
world. The beneﬁts of Embedded Systems were
identiﬁed in this project, as well as their disadvan-
tages. Technological issues were encountered, and
through COE718’s course material and experiments,
as well as a robust engineering foundation, these

Page 14 of 49

Giamblanco, N.

REFERENCES

Ryerson University

[1] A. Ltd and A. G. GmbH, "Introduction," in ARM, 2005.
http://www.keil.com/support/man/docs/mcb1700/mcb1700_intro.htm. Accessed: Nov. 29, 2016.

[Online].

Available:

[2] G. Khan, "Sub_objective1," in COE718 Course Website, 2016.

[Online]. Available:

http://www.ee.ryerson.ca/ courses/coe718/. Accessed: Nov. 29, 2016.

[3] "LaTeX - A document preparation system," 2016.

[Online]. Available: https://www.latex-

project.org/. Accessed: Nov. 29, 2016.

[4]

.

[Online].

Available:

http://www.ee.ryerson.ca/ courses/ee8205/Data-Sheets/Cortex-

M3/NXP%20LPC17XX%20User%20Manual.pdf. Accessed: Nov. 29, 2016.

Page 15 of 49

Giamblanco, N.

APPENDIX

usbmain.c

Ryerson University

/*----------------------------------------------------------------------------

usbmain.c

* Name:
* Purpose: USB Audio Class Demo
* Version: V1.20
*----------------------------------------------------------------------------
*
*
*
*
*
*
*
*
* Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
*---------------------------------------------------------------------------*/

This software is supplied "AS IS" without any warranties, express,
implied or statutory, including but not limited to the implied
warranties of fitness for purpose, satisfactory quality and
noninfringement. Keil extends you a royalty-free right to reproduce
and distribute executable files created using this software for use
on NXP Semiconductors LPC microcontroller devices only. Nothing else
gives you the right to use this software.

/* LPC17xx definitions */

#include "LPC17xx.h"
#include "type.h"
#include <stdio.h>
#include "usb.h"
#include "usbcfg.h"
#include "usbhw.h"
#include "usbcore.h"
#include "usbaudio.h"
#include "GLCD.h"
#include "KBD.h"
#include <string.h>

extern void SystemClockUpdate(void);
extern uint32_t SystemFrequency;
uint8_t Mute;
uint32_t Volume;
int count=0;
int run=0;

/* Mute State */
/* Volume Level */

Page 16 of 49

Giamblanco, N.

Ryerson University

#if USB_DMA
uint32_t *InfoBuf = (uint32_t *)(DMA_BUF_ADR);
short *DataBuf = (short *)(DMA_BUF_ADR + 4*P_C);
#else
uint32_t InfoBuf[P_C];
short DataBuf[B_S];
#endif

/* Data Buffer */

uint16_t DataOut;
uint16_t DataIn;

DataRun;

uint8_t
uint16_t PotVal;
uint32_t VUM;
uint32_t Tick;

/*

* Get Potenciometer Value
*/

void get_potval (void) {

uint32_t val;

LPC_ADC->CR |= 0x01000000;
do {

val = LPC_ADC->GDR;

} while ((val & 0x80000000) == 0);
LPC_ADC->CR &= ~0x01000000;
PotVal = ((val >> 8) & 0xF8) +

((val >> 7) & 0x08);

}

/* Data Out Index */
/* Data In Index */

/* Data Stream Run State */
/* Potenciometer Value */
/* VU Meter */
/* Time Tick */

/* Start A/D Conversion */

/* Read A/D Data Register */
/* Wait for end of A/D Conversion */
/* Stop A/D Conversion */
/* Extract Potenciometer Value */

Page 17 of 49

Giamblanco, N.

Ryerson University

/*

* Timer Counter 0 Interrupt Service Routine
executed each 31.25us (32kHz frequency)
*
*/

void TIMER0_IRQHandler(void)
{
int js_input;

long val;

char VOLUME[12];

uint32_t cnt;

if (DataRun && run==0) {

/* Data Stream is running */

val = DataBuf[DataOut];
cnt = (DataIn - DataOut) & (B_S - 1);
if (cnt == (B_S - P_C*P_S)) {

DataOut++;

}
if (cnt > (P_C*P_S)) {

DataOut++;

}
DataOut &= B_S - 1;
if (val < 0) VUM -= val;
else
VUM += val;
val *= Volume;
val >>= 16;
val
val

+= 0x8000;
&= 0xFFFF;

} else {

val = 0x8000;

}

if (Mute) {

val = 0x8000;

/* Get Audio Sample */
/* Buffer Data Count */
/* Too much Data in Buffer */
/* Skip one Sample */

/* Still enough Data in Buffer */
/* Update Data Out Index */

/* Adjust Buffer Out Index */
/* Accumulate Neg Value */
/* Accumulate Pos Value */
/* Apply Volume Level */
/* Adjust Value */
/* Add Bias */
/* Mask Value */

/* DAC Middle Point */

/* DAC Middle Point */

Page 18 of 49

Giamblanco, N.

}

Ryerson University

LPC_DAC->CR = val & 0xFFC0;

/* Set Speaker Output */

if ((Tick++ & 0x03FF) == 0) {

get_potval();
if (VolCur == 0x8000) {

Volume = 0;

} else {

/* On every 1024th Tick */
/* Get Potenciometer Value */
/* Check for Minimum Level */
/* No Sound */

Volume = VolCur * PotVal;

/* Chained Volume Level */

}
val = VUM >> 20;
VUM = 0;
if (val > 7) val = 7;

}

js_input=get_button();

/* Scale Accumulated Value */
/* Clear VUM */
/* Limit Value */

switch(js_input){

case 0x08:
GLCD_Clear(White);
GLCD_DisplayString(4,0,1,"Start Streaming...");
USB_Connect(TRUE);

run=0;

break;
case 0x10:
GLCD_Clear(Blue);
GLCD_DisplayString(4,0,1,"Music Playing...");

run=0;

break;

case 0x40:

GLCD_Clear(Green);
GLCD_DisplayString(4,0,1,"Music Pausing...");

run=1;

Page 19 of 49

Ryerson University

Giamblanco, N.

break;

case 0x20:
GLCD_Clear(Yellow);
GLCD_DisplayString(4,0,1,"Stopping Streaming.");
USB_Connect(FALSE);
break;

}

}

LPC_TIM0->IR = 1;

/* Clear Interrupt Flag */

Main Function

/*****************************************************************************
**
******************************************************************************/
int main (void)
{

main()

volatile uint32_t pclkdiv, pclk;

int js_input;

/* SystemClockUpdate() updates the SystemFrequency variable */
SystemClockUpdate();

LPC_PINCON->PINSEL1 &=~((0x03<<18)|(0x03<<20));
/* P0.25, A0.0, function 01, P0.26 AOUT, function 10 */
LPC_PINCON->PINSEL1 |= ((0x01<<18)|(0x02<<20));

/* Enable CLOCK into ADC controller */
LPC_SC->PCONP |= (1 << 12);

LPC_ADC->CR = 0x00200E04; /* ADC: 10-bit AIN2 @ 4MHz */
LPC_DAC->CR = 0x00008000; /* DAC Output set to Middle Point */

/* By default, the PCLKSELx value is zero, thus, the PCLK for

Page 20 of 49

Giamblanco, N.

Ryerson University

all the peripherals is 1/4 of the SystemFrequency. */
/* Bit 2~3 is for TIMER0 */
pclkdiv = (LPC_SC->PCLKSEL0 >> 2) & 0x03;
switch ( pclkdiv )
{

case 0x00:
default:

pclk = SystemFrequency/4;

break;
case 0x01:

pclk = SystemFrequency;

break;
case 0x02:

pclk = SystemFrequency/2;

break;
case 0x03:

pclk = SystemFrequency/8;

break;

}
GLCD_Init();

GLCD_Clear(White);
GLCD_DisplayString(0,2,1,"###Music Player###");
GLCD_DisplayString(5,1,0,"[Up] Begins Streaming. [Down] Stops Streaming.");
KBD_Init();

LPC_TIM0->MR0 = pclk/DATA_FREQ - 1; /* TC0 Match Value 0 */
LPC_TIM0->MCR = 3; /* TCO Interrupt and Reset on MR0 */
LPC_TIM0->TCR = 1; /* TC0 Enable */
NVIC_EnableIRQ(TIMER0_IRQn);

USB_Init(); /* USB Initialization */
//USB_Connect(TRUE); /* USB Connect */

/********* The main Function is an endless loop ***********/

Page 21 of 49

Giamblanco, N.

while( 1 );

}

Ryerson University

/******************************************************************************
**
******************************************************************************/

End Of File

Terminal.h

/*------------------------------------------------------------------------------

RL-ARM

Terminal.h

Name:
Purpose: File manipulation example terminal definitions

*
*------------------------------------------------------------------------------
*
*
*------------------------------------------------------------------------------
*
*
*----------------------------------------------------------------------------*/

This code is part of the RealView Run-Time Library.
Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.

enum {BACKSPACE = 0x08,
= 0x0A,
= 0x0D,
= 0x11,
= 0x13,
= 0x1B,
= 0x7F };

LF
CR
CNTLQ
CNTLS
ESC
DEL

/* External functions */
extern int getline
extern int getlineSecure (char *buf, int bufsz);
extern int sendchar (int ch);
extern int getkey

(char *buf, int bufsz);

(void);

/*------------------------------------------------------------------------------

* end of file
*----------------------------------------------------------------------------*/

Page 22 of 49

Giamblanco, N.

Ryerson University

PasswordGen.c

PasswordGen.c

Password Generator

Name:
Purpose: Generate a Cryptographically Secure Program

/*------------------------------------------------------------------------------
*
*------------------------------------------------------------------------------
*
*
*------------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void genPassword(char pass[]){
short i=0;
short j=0;
for(j=0;j<5;++j)
for(i=0;i<8;++i){
pass[i]=(pass[i]^rand())%90+32;
}
}

/*------------------------------------------------------------------------------

* end of file
*----------------------------------------------------------------------------*/

snake.c

Snake Game

/*------------------------------------------------------------------------------
*
*------------------------------------------------------------------------------
*
*
*------------------------------------------------------------------------------

Name:
Purpose: Provide the logic for the Snake Game

snake.c

Page 23 of 49

Giamblanco, N.

Ryerson University

*----------------------------------------------------------------------------*/
#include <RTL.h>
#include <rl_usb.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "Terminal.h"
#include "GLCD.h"
#include <string.h>
#include "snake_1.c"
#include "food_1.c"

/* standard I/O .h-file

/* character functions

*/

*/

/***************************************************************
Will have to navigate around the screen using

[w]
[a] [s] [d]

****************************************************************/

/***********************************
Max Length the snake can grow to.
***********************************/
const int width=50;
const int height=60;
const int size=width*height;

// User Stats...
char users[5][10];
int userScores[5];
int recentPlayers=0;

int isHit=0;

int bodyLen=1;
int map[size][2];
// Speed At Which Player Updates Coordinates
int dx=3;
int dy=3;

Page 24 of 49

Giamblanco, N.

Ryerson University

//Food Coordinates
int foodx,foody;

//Points
int points=0;
int highscore=0;
char score[1]="";
char hscore[1]="";

//used for to move continually..
int case_=0;

//Playing Field

void init(){
int i=0;

bodyLen=1;

points=0;
map[0][0]=120;
map[0][1]=160;
map[1][0]=124;
map[1][1]=160;
foodx=rand()%240;
foody=rand()%320;
GLCD_DisplayString

(4, 2, 0, (unsigned char *)"WELCOME TO SNAKE. [w] to Play.");

while(usbh_hid_kbd_getkey (0, 0)!=119){

}
printf("Loading...\n\n");
for(i=0;i<1000000;++i){
if(i%10000==0){
printf("*");
}

Page 25 of 49

Ryerson University

Giamblanco, N.

}
GLCD_Clear(Black);
GLCD_ClearLn(0,0);

}

void draw(){
int i=0;

for(i=bodyLen;i>=0;i--){
GLCD_Bitmap(map[i][0],map[i][1],3,3,(unsigned char*)SNAKE1_pixel_data_black);
}

//GLCD_Bitmap(foodx,foody,4,4,(unsigned char*)FOOD_pixel_data_black);

if(map[0][0]>240){
map[0][0]=0;
}
if(map[0][0]<0){
map[0][0]=240;
}
if(map[0][1]>320){
map[0][1]=0;
}
if(map[0][1]<0){
map[0][1]=320;
}
switch(case_){
case 0:
map[0][1]=map[0][1]-dy;
break;
case 1:
map[0][0]=map[0][0]-dx;
break;
case 2:
map[0][1]=map[0][1]+dy;

Page 26 of 49

Giamblanco, N.

Ryerson University

break;
case 3:
map[0][0]=map[0][0]+dx;
break;

}
//GLCD_Bitmap(map[0][0],y,4,4,(unsigned char*) SNAKE1_pixel_data);
//Small Food Drawing.
GLCD_Bitmap(foodx,foody,4,4,(unsigned char*)FOOD_pixel_data);

GLCD_Bitmap(map[0][0],map[0][1],3,3,(unsigned char*)SNAKE1_pixel_data);

for(i=bodyLen;i>0;i--){
map[i][0]=map[i-1][0];
map[i][1]=map[i-1][1];
GLCD_Bitmap(map[i][0],map[i][1],3,3,(unsigned char*)SNAKE1_pixel_data);
}

GLCD_DisplayString
if(points>0){
GLCD_DisplayString
GLCD_DisplayString
}
for(i=0;i<1000000;++i){

(0, 0, 0, (unsigned char *)"[ESC] to Exit.");

(0, 16, 0, (unsigned char *)"Score: ");
(0, 23, 0, (unsigned char *)score);

}

}
void detectCollisions(){

int i=0;

for(i = bodyLen; i> 0; i--){

if((i>4)&& (map[i][0]==map[0][0]) && (map[i][1]==map[0][1])){
isHit=1;

Page 27 of 49

Giamblanco, N.

Ryerson University

}

}

if(map[0][0]<foodx+4&&map[0][0]+4>foodx &&map[0][1]<foody+4 &&map[0][1]+4>foody){
GLCD_Bitmap(foodx,foody,4,4,(unsigned char*)FOOD_pixel_data_black);
++bodyLen;
if(bodyLen<50*60){
map[bodyLen][0]=map[bodyLen-1][0]+5;
map[bodyLen][1]=map[bodyLen-1][1]+5;
foodx=rand()%240;
foody=rand()%320;

}
++points;
userScores[recentPlayers-1]=points;
sprintf(score,"%d",points);
if(points > highscore){
highscore=points;
}
}

}

int updateLocation(){
int n;
n=usbh_hid_kbd_getkey (0, 0);

if(isHit==1){
return -1;
}

if(n==119){

Page 28 of 49

Giamblanco, N.

Ryerson University

//printf("UP!\n");
if(case_!=2){
case_=0;
}else{
return -1;
}
}
if(n==97){
//printf("LEFT!\n");
if(case_!=3){
case_=1;
}else{
return -1;
}

}
if(n==115){
//printf("DOWN!\n");
if(case_!=0){
case_=2;
}else{
return -1;
}

}
if(n==100){
//printf("RIGHT!\n");
if(case_!=1){
case_=3;
}else{
return -1;
}

}

if(n==0x1B){
GLCD_Clear(Black);

Page 29 of 49

Giamblanco, N.

return 0;
}
else
return 1;
}

Ryerson University

//Main Loop For Game
int play(char *name){
//For Status Of Game...
int status=1;
int i=0;
//For record of scores and player names...
if(recentPlayers<5){
strncpy(users[recentPlayers],name,strlen(name)-1);
++recentPlayers;
}else{
recentPlayers=1;
}

GLCD_Clear(Black);
GLCD_SetBackColor(Black);
GLCD_SetTextColor(Green);
GLCD_ScrollVertical(320);
init();

while(status==1){
draw();
detectCollisions();
status=updateLocation();
if(status==-1){

userScores[recentPlayers-1]=points;

Page 30 of 49

Giamblanco, N.

Ryerson University

GLCD_Clear(Black);
sprintf(hscore,"%d",highscore);
GLCD_DisplayString
GLCD_DisplayString
GLCD_DisplayString
GLCD_DisplayString
GLCD_DisplayString

(0, 0, 0, (unsigned char *)"YOU LOST. ESC to EXIT");
(2, 0, 0, (unsigned char *)">> High Score: ");
(2, 17, 0, (unsigned char *)hscore);
SCORE");
(4, 0, 0, (unsigned char *)"USER
(5, 0, 0, (unsigned char *)"************+*********");

:

while(i<recentPlayers){
sprintf(score,"%d",userScores[i]);
GLCD_DisplayString(i+6,0,0,(unsigned char*)users[i]);
GLCD_DisplayString(i+6,12,0,(unsigned char*)"|");
GLCD_DisplayString(i+6,15,0,(unsigned char*)score);
++i;
}

while(usbh_hid_kbd_getkey (0, 0)!=0x1B){
//Waiting for user reaction...
}
}
}
GLCD_Clear(Black);
GLCD_ScrollVertical(320);
return status;

}

Retarget.c

RL-ARM

Retarget.c

/*------------------------------------------------------------------------------
*
*------------------------------------------------------------------------------
*
*
*
*------------------------------------------------------------------------------

Name:
Purpose: Retarget input to the USB keyboard and

output to the LCD display

Page 31 of 49

Giamblanco, N.

Ryerson University

This code is part of the RealView Run-Time Library.
Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.

*
*
*----------------------------------------------------------------------------*/

#include <RTL.h>
#include <stdio.h>
#include <string.h>
#include <rt_sys.h>
#include <rl_usb.h>
#include "GLCD.h"

extern short getBackCol(void);

struct __FILE { int handle; /* Add whatever you need here */ };
FILE __stdout;

#ifdef STDIO

/*------------------------------------------------------------------------------

Write character to the LCD display
*----------------------------------------------------------------------------*/
int sendchar (int ch) {

static int lnd = 0;
static int ln
= 0;
static int col = 0;

if (ch == 0x0A) {

/* Line Feed */

col = 0;
lnd++;
ln ++;
if (lnd >= 40)

lnd = 0;

if (ln >= 40) {

ln=0;
GLCD_Clear(getBackCol());

//GLCD_ScrollVertical (30);

Page 32 of 49

Giamblanco, N.

Ryerson University

//GLCD_ClearLn (lnd, 0);

}

} else if (ch == 0x0D) {

/* Carriage Return */

col = 0;

} else if (ch == 0x08) {

/* Backspace */

if (col)

col --;

} else {

GLCD_DisplayChar (lnd, col++, 0, (unsigned char) ch);

}

return (ch);

}

/*------------------------------------------------------------------------------

Read character from the USB keyboard
*----------------------------------------------------------------------------*/
int getkey (void) {

return (usbh_hid_kbd_getkey (0, 0));

}
#endif

/*--------------------------- fputc ------------------------------------------*/

int fputc (int ch, FILE *f) {
#ifdef STDIO

return (sendchar (ch));

#endif
}

/*--------------------------- fgetc ------------------------------------------*/

int fgetc (FILE *f) {
#ifdef STDIO

Page 33 of 49

Giamblanco, N.

Ryerson University

return (getkey ());

#endif
}

/*--------------------------- ferror -----------------------------------------*/

int ferror (FILE *f) {

/* Your implementation of ferror */
return EOF;

}

/*--------------------------- _ttywrch ---------------------------------------*/

void _ttywrch (int ch) {
#ifdef STDIO

sendchar (ch);

#endif
}

/*--------------------------- _sys_exit --------------------------------------*/

void _sys_exit (int return_code) {

/* Endless loop. */
while (1);

}

/*------------------------------------------------------------------------------

* end of file
*----------------------------------------------------------------------------*/

Main.c

/*------------------------------------------------------------------------------
*
*------------------------------------------------------------------------------
*
*

Name:
Purpose: The Entrance to the Media Center

RL-ARM - USB

Main.c

Page 34 of 49

Giamblanco, N.

Ryerson University

*------------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

#include <RTL.h>
#include <rl_usb.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "Terminal.h"
#include "GLCD.h"
#include <string.h>
//Including Photos...
//#include "robot.c"
//#include "apple.c"

//Including Game
#include "snake.h"
#include "Measure.h"

/* standard I/O .h-file

/* character functions

*/

*/

/* global project definition file

*/

//For Foto Gallery
extern const unsigned char APPLE_pixel_data[];
extern const unsigned char ROBOT_pixel_data[];

//For Screen Saver...
extern int ScreenSaver(void);
extern void settings(void);
extern void genPassword(char pass[]);

//For Screen Settings
extern short getBackCol(void);
extern short getTextCol(void);
extern short getTextBackCol(void);

const char menu[] =

"\n"
"########################################\n"
"# Mbed OS - v1.1
#\n"

Page 35 of 49

Giamblanco, N.

Ryerson University

----+ DESC --------------

#\n"
"# A UNIX Style Operating Sys.
"########################################\n"
#\n"
"# CMND
"# [f]
#\n"
| Goes to Foto Menu
| Goes to the Game Menu. #\n"
"# [p]
#\n"
| Puts System to Sleep
"# [s]
"# [m]
| Shows Musik Menu
#\n"
#\n"
| Sys Settings.
"# [-]

"# [c]

| Clears Screen.

#\n"

"# [z]
"# [h]
"########################################\n";

| Password Generator.
| Displays this.

#\n"
#\n"

int volatile connected=0; /*is Keyboard connected */

char ERR [] = "\n*** ERROR: %s\n";
char name[10];
char in;

/* ERROR message string in code

*/

#define WRONGINDEX 0xffff

/* error signal for wrong index

*/

/*********************************
chill(): A delay function (wasting CPU time)
**********************************/
void chill(){
int i=0,j=0;

for(i=0;i<100000;++i)
for(j=0;j<25;++j);

}

/*********************************
hang(): A delay function (wasting CPU time)

Page 36 of 49

Giamblanco, N.

Ryerson University

**********************************/
void hang(){
int i=0,j=0;
for(i=0;i<100000;++i)
for(j=0;j<1000;++j);

}

void showPhotos(){

GLCD_Clear(Black);
GLCD_Bitmap(50,100,100,100,(unsigned char*)APPLE_pixel_data);

hang();
GLCD_Clear(Black);
GLCD_Bitmap(50,100,100,100,(unsigned char*)ROBOT_pixel_data);
hang();

}

void clear(){

GLCD_Clear (getBackCol());

GLCD_SetTextColor (getTextCol());

GLCD_SetBackColor(getTextBackCol());

/* Clear the grapic LCD

/* Set text color to blue

}

void termMenu(){
char cmdbuf [5];
char password[8];

Page 37 of 49

Giamblanco, N.

Ryerson University

int n;
n=getline(cmdbuf, 5);

if(n!=0){

/* input command line */

if (cmdbuf[0] == ’h’) {
printf ("%s",menu);
}
if (cmdbuf[0] == ’m’) {
printf ("Going to Musik.\nPlease Ensure You Check Your Computer.\n");
}
if (cmdbuf[0]== ’f’) {
printf ("Going to Foto Viewer\n");
showPhotos();
clear();
}
if (cmdbuf[0]==’c’){
clear();

}
if (cmdbuf[0]==’z’){
printf("**Generating a Password** \n\n");
genPassword(password);
printf("Password:
printf("******************************\n");
}
if (cmdbuf[0]==’-’){
settings();

%s\n\n",password);

}
if (cmdbuf[0]==’s’){
ScreenSaver();
clear();
}
if (cmdbuf[0]== ’p’) {
printf("[return] To End Input.\n\n");
printf ("Player Title?\n>> ");

Page 38 of 49

Giamblanco, N.

Ryerson University

while(getline(name,10)==0){

}
printf("About to Start...%s\n",name);
play(name);
clear();
}
printf ("\n~#: ");
}

}

/******************************************************************************/
/***************************
***************************/
/******************************************************************************/
int main (void)
*/

/* main entry for program

MAIN PROGRAM

{

char con
=
char con_ex =
char out
=
int

i;

0;
2;
1;

/* Connection status of kbd
/* Previous connection status
/* Output to keyboard LEDs
/* index for command buffer

*/
*/
*/
*/

GLCD_Init ();
GLCD_Clear (getBackCol());
GLCD_SetTextColor (getTextCol());
GLCD_SetBackColor(getTextBackCol());
usbh_init(0);

/*Initialize the graphic LCD */
/* Clear the graphic LCD */
/* Set text color from user preference*/

/* Initialize USB Host

for (i = 0; i < 1000000; i++) {

/* allow kbd connect detect

usbh_engine(0);
if (usbh_hid_status(0, 0))

break;

/* if connected, break

Page 39 of 49

*/

*/

*/

Giamblanco, N.

}

while (1)

{

usbh_engine(0);
con = usbh_hid_status(0, 0);
if (con ^ con_ex) {

if (con) {

Ryerson University

/* loop forever

/* If kbd connection status

usbh_hid_data_out (0, 0, (U8 *)&out,1);/* Turn on NUM LED

connected=1;

} else {

connected=0;

printf ("\nConnect the keyboard ...\n");

*/

*/

*/

}
con_ex = con;

}

printf("%s",menu);
printf ("\n~#: ");
while(1){
termMenu();
}

}
}
/*------------------------------------------------------------------------------

* end of file
*----------------------------------------------------------------------------*/

Getline.c

RL-ARM

Getline.c

/*------------------------------------------------------------------------------
*
*------------------------------------------------------------------------------
*
*
*------------------------------------------------------------------------------

Name:
Purpose: Line Edited Character Input

Page 40 of 49

Giamblanco, N.

Ryerson University

This code is part of the RealView Run-Time Library.
Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.

*
*
*----------------------------------------------------------------------------*/

#include <RTL.h>
#include <stdio.h>
#include "Terminal.h"

/*------------------------------------------------------------------------------

Line Editor

*
*----------------------------------------------------------------------------*/

int getline (char *line, int n)

{

= 0;

static int
int
int
char c;

cnt
cnt1;
key;

line += cnt;
key = getkey ();
if (key >= 0) {

c = (char)(key);
if (c == CR)
if (c == BACKSPACE
{

if (cnt != 0)

c = LF;

|| c == DEL)

{

cnt--;
line--;
sendchar (BACKSPACE);
sendchar (’ ’);
sendchar (BACKSPACE);

}

}
else if (c == ESC) {

*line++ = c;
cnt++;

}

/* Read key from Serial port

/* CR = LF
/* process backspace

/* decrement count
/* and line pointer
/* echo backspace

*/

*/
*/

*/
*/
*/

*/
/* process escape
/* store character and increment */
/* and count
*/

Page 41 of 49

Giamblanco, N.

Ryerson University

else if (c != CNTLQ &&

c != CNTLS ) {
sendchar (*line = c);
line++;
cnt++;

/* ignore: Control Q = XON
/*
Control S = XOFF
/* echo and store character
/* increment line pointer
/* and count

*/
*/
*/
*/
*/

}
if ((cnt >= n - 1) || (c == LF) || (c == ESC)) {

/* mark end of string

/* mark end of string

*/

//*line = ’\0’;

*line = 0;
cnt1
cnt
return (cnt1);

= cnt;
= 0;

}

}

return (0);

}

int getlineSecure (char *line, int n)

{

= 0;

static int
int
int
char c;

cnt
cnt1;
key;

line += cnt;
key = getkey ();
if (key >= 0) {

c = (char)(key);
if (c == CR)
if (c == BACKSPACE
{

if (cnt != 0)

c = LF;

|| c == DEL)

{

cnt--;
line--;
sendchar (BACKSPACE);
sendchar (’ ’);
sendchar (BACKSPACE);

}

/* Read key from Serial port

/* CR = LF
/* process backspace

/* decrement count
/* and line pointer
/* echo backspace

*/

*/
*/

*/
*/
*/

Page 42 of 49

Giamblanco, N.

Ryerson University

}
else if (c == ESC) {

*line++ = c;
cnt++;

}
else if (c != CNTLQ &&

/* process escape
*/
/* store character and increment */
/* and count
*/

/* ignore: Control Q = XON

*/

c != CNTLS ) {

/*

Control S = XOFF

*/

*line = c;
sendchar (BACKSPACE);
sendchar (’ ’);
sendchar (BACKSPACE);
sendchar (’*’);
line++;
cnt++;

/* echo and store character

*/

/* increment line pointer
/* and count

*/
*/

}
if ((cnt >= n - 1) || (c == LF) || (c == ESC)) {

/* mark end of string

/* mark end of string

*/

//*line = ’\0’;

*line = 0;
cnt1
cnt
return (cnt1);

= cnt;
= 0;

}

}

return (0);

}

/*------------------------------------------------------------------------------

* end of file
*----------------------------------------------------------------------------*/

ScreenSaver.c

#include <RTL.h>
#include <rl_usb.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

/* standard I/O .h-file

/* character functions

*/

*/

Page 43 of 49

Giamblanco, N.

Ryerson University

#include "Terminal.h"
#include "GLCD.h"
#include <string.h>

unsigned short colours[]={Black,Navy,DarkGreen,DarkCyan,Maroon,Purple,Olive,DarkGrey,Blue,Green,Cyan,Red,Magenta,Yellow};

short back=Black;
short text=Green;

char setMenu[]=
"+###################+\n"

"| ~#:Settings

|\n"

"+######+############+\n"
"| [1] | Background |\n"
"| [2] | Text Color |\n"

"| [esc]| Exit

|\n"

"+######+############+\n";

|"

|"

char colour_menu[]=
"[1] - Black
"[2] - Navy\n"
"[3] - Dark Green |"
"[4] - Dark Cyan\n"
"[5] - Maroon
"[6] - Purple\n"
"[7] - Olive
"[8] - Dark Grey\n"
"[9] - Blue
"[a] - Green\n"
"[b] - Cyan
"[c] - Red\n"
"[d] - Magenta
"[e] - Yellow\n";

|"

|"

|"

|"

int colourChoose(){
int run=0;
int colr=0;

Page 44 of 49

Giamblanco, N.

Ryerson University

int n=0;
char col[3];
printf("%s\n\n>> ",colour_menu);
while(run==0){
n=getline(col,3);
while(n!=0){
switch(col[0]){

case ’1’:
printf("Black Selected.\n");
colr= 0;
break;

case ’2’:
printf("Navy Selected.\n");
colr= 1;
break;
case ’3’:
printf("Dark Green Selected.\n");
colr= 2;
break;
case ’4’:
printf("Dark Cyan Selected.\n");
colr= 3;
break;

case ’5’:
printf("Maroon Selected.\n");
colr=4;
break;

case ’6’:
printf("Purple Selected.\n");
colr= 5;
break;

case ’7’:

Page 45 of 49

Giamblanco, N.

Ryerson University

printf("Olive Selected.\n");
colr= 6;
break;

case ’8’:
printf("Dark Grey Selected.\n");
colr =7;
break;

case ’9’:
printf("Blue Selected.\n");
colr= 8;
break;

case ’a’:
printf("Green Selected.\n");
colr= 9;
break;

case ’b’:
printf("Cyan Selected.\n");
colr=10;
break;

case ’c’:
printf("Red Selected.\n");
colr=11;
break;
case ’d’:
printf("Magenta Selected.\n");
colr=12;
break;
case ’e’:
printf("Yellow Selected.\n");
colr=13;
break;

}
n=0;

Page 46 of 49

Ryerson University

Giamblanco, N.

run=1;
}

}
printf("\n*-.Colour Has been Selected.-*\n");
return colr;

}

/**
Create Screen Saver...
**/
int ScreenSaver(){
int count=0;
GLCD_SetTextColor(Green);
GLCD_Clear(Black);
while(getkey()==-1){

GLCD_DisplayChar(rand()%240+1,rand()%380+1,0,’$’);
GLCD_SetTextColor(count);
++count;
if(count==65536){
count=0;

}

}

return 0;
}

short getBackCol(){

return back;

}

Page 47 of 49

Giamblanco, N.

Ryerson University

short getTextBackCol(){
return back;
}

short getTextCol(){

return text;
}
/**
Create Settings Menu
**/
void settings(){
int run=0;
int n=0;
char cmd[3];
printf("%s\n\n>> ",setMenu);
while(run==0){
n=getline(cmd,3);
//printf("\n");
while(n!=0){

switch(cmd[0]){
case ’1’:
//Back Setting...
back=colours[colourChoose()];
GLCD_Clear(back);

GLCD_SetBackColor(back);
printf("Background Color Set.\n");
printf("\n>> ");

break;
case ’2’:
text=colours[colourChoose()];
GLCD_SetTextColor(text);

printf("Text Color Set.\n");

printf("\n>> ");
break;
case 0x1B:

Page 48 of 49

Giamblanco, N.

run=1;

printf("Going Back To Main...\n\n");

Ryerson University

break;
}

n=0;
}

}

}

Page 49 of 49

