SiFT: Signature Based Fault Tolerance for

High-Level Synthesis

Nicholas Giamblanco

Department of Electrical and

Computer Engineering
University of Toronto

Ontario, Canada

nicholas.giamblanco@mail.utoronto.ca

Ishita Ray

Department of Electrical and

Computer Engineering
University of Toronto

Ontario, Canada

ish.ray@mail.utoronto.ca

AbstractWe present a correctness checking tool for high-
level synthesis, SiFT, which aims to prole and modify high-
level descriptions at the function level to provide fault tolerance.
We rst inspect code statically, through use of SATURN [1],
to check for various softwares bugs such as null pointers,
deadlock, memory bugs (off-by-1 errors), etc. Upon successful
code inspection, we prole code at the function level of a high-
level description. SiFT introduces Function Characterization, a
logically deduced signature of function output & behaviour which
asserts synthesized hardware functions behave as described in
software. We implement SiFT as an LLVM compiler pass, to
facilitate integration into the existing high-level synthesis tool
LegUp [2]. We will test SiFT by executing LegUp against the
CHStone benchmarks [3] and two handwritten test cases and
check for the consumed area and performance degradation while
noting on the number of logical and memory bugs discovered
upon SiFTs operation. We will also utilize Quartuss Fault
Injection tool [4] to identify the resilience of the generated
hardware description in the presence of single event upsets (SEU).

I. INTRODUCTION

Modern systems on chip (SoC) design methodologies have
facilitated the growth and acceleration of many applications
(i.e Machine learning [5], Timing Critical Applications [6],
etc.), yet have neglected verication of the produced design
against its specication. One such methodology, high-level
synthesis, suffers from this negligence. High-level synthesis
compiles a high-level description (usually written in C) to a
corresponding hardware description written in either Verilog
or VHDL. This design process enables faster time-to-market
than constructing digital circuit designs by hand. However,
this automation vigorously optimizes the high-level description
during compilation, which can lead to unwanted bug gener-
ation in the resulting hardware description. Additionally the
hardware description may lose the semantic structure upheld
in the high-level language for some algorithmic description.
This can make debugging faulty hardware designs difcult to
traceback to the offending high level language. Additionally,
high-level synthesis suffers from single event upset

II. RELATED WORK

A. Bug Detection Methods within High Level Synthesis

B. Correctness Checking Methods

C. Signature Analysis

D. Variational AutoEncoders

III. OUR APPROACH

In this section, we discuss our proposed correctness check-
ing mechanism which we call SIFT. We attempt to provide
correctness checking behaviour at the function level of a high-
level description. Our approach performs the following:

1) Proling code through JITed execution of functions
with simulated inputs, in hopes of detecting runtime
bugs with memory operations, and logical errors. We
identify this step as Function Inspection. This operation
is described in Section III-B

2) Identifying the signature of a function described in a
HLL. We will refer to this as Function Characterization.
This will be described in Section III-C

3) Appending a logical check to a function for the assur-
ance said function matches its Function Characteriza-
tion. We will refer to this Function Certication which
is described in Section III-D.

A. Modied High-Level Synthesis Flow

As noted earlier, HLS is able to map a high-level algorithmic
description, into an equivalent hardware description. This is
generally done

[2]

B. Function Inspection

C. Function Characterization

D. Function Certication

IV. IMPLEMENTATION STATUS

The proposed approach

REFERENCES

[1] Y. Xie and A. Aiken, Saturn: A sat-based tool for bug detection, in
International Conference on Computer Aided Verication, pp. 139143,
Springer, 2005.

[2] A. Canis, J. Choi, M. Aldham, V. Zhang, A. Kammoona, J. H. Anderson,
S. Brown, and T. Czajkowski, Legup: high-level synthesis for fpga-based
processor/accelerator systems, in Proceedings of the 19th ACM/SIGDA
international symposium on Field programmable gate arrays, pp. 3336,
ACM, 2011.

[3] Y. Hara, H. Tomiyama, S. Honda, H. Takada, and K. Ishii, Chstone: A
benchmark program suite for practical c-based high-level synthesis, in
Circuits and Systems, 2008. ISCAS 2008. IEEE International Symposium
on, pp. 11921195, IEEE, 2008.

[4] Q. I. Altera, Handbook version 13.1, QII52005-13.1. 0, vol. 2, pp. 121,

2013.

[5] C. Zhang, P. Li, G. Sun, Y. Guan, B. Xiao, and J. Cong, Optimizing
fpga-based accelerator design for deep convolutional neural networks, in
Proceedings of the 2015 ACM/SIGDA International Symposium on Field-
Programmable Gate Arrays, pp. 161170, ACM, 2015.

[6] C. Leber, B. Geib, and H. Litz, High frequency trading acceleration
using fpgas, in Field Programmable Logic and Applications (FPL), 2011
International Conference on, pp. 317322, IEEE, 2011.

