SiFT: Signature Based Fault Tolerance for

High-Level Synthesis

Nicholas Giamblanco

Department of Electrical and

Computer Engineering
University of Toronto

Ontario, Canada

nicholas.giamblanco@mail.utoronto.ca

Ishita Ray

Department of Electrical and

Computer Engineering
University of Toronto

Ontario, Canada

ish.ray@mail.utoronto.ca

AbstractWe present a correctness checking tool for high-
level synthesis, SiFT, which aims to prole and modify high-
level descriptions at the function level to provide area-aware
fault tolerance. We rst inspect code statically, through use of
SATURN [1], to check for various softwares bugs such as but
not limited to null pointers, deadlock, memory bugs (off-by-1
errors, etc.). Upon successful code inspection, we prole code
at the function level of a high-level description. SiFT introduces
Function Characterization, a bit-pattern signature of function
output & behaviour which asserts synthesized hardware functions
behave as described in software. We implement SiFT as an LLVM
[2] compiler pass, to facilitate integration into the existing high-
level synthesis tool LegUp [3]. We will test SiFT by executing
LegUp against the CHStone benchmarks [4] and two handwritten
test cases and check for the consumed area and performance
degradation while noting on the number of logical and memory
bugs initially discovered upon SiFTs operation. We will also
utilize Quartuss Fault Injection tool [5] to identify the resilience
of the generated hardware description in the presence of single
event upsets (SEU).

I. INTRODUCTION

Modern systems on chip (SoC) design methodologies have
facilitated the growth and acceleration of many applications
(i.e Machine learning [6], Timing Critical Applications [7],
etc.), with the majority of these methodologies enforcing
proper verication of the produced design. This idea of check-
ing for correctness has been studied heavily within the eld
of digital hardware design.Verication methods outlined in [8]
provide details in which hardware can be sufciently veried.
Additionally, both hardware description and verication can be
combined into one unied language such as System Verilog.
However, one recent design strategy, high-level synthesis,
does not provide such strict verication measures. High-level
synthesis compiles a high-level description (usually written
in C) to a corresponding hardware description, described in
either Verilog or VHDL. This description is then synthesized
to hardware, which is typically a eld programmable gate
array. This design process enables faster time-to-market than
constructing digital circuit designs by hand.

However, this high-level synthesis process vigorously op-

timizes1 the high-level description during compilation, which
can lead to unwanted bug generation in the resulting hardware
description. Additionally the hardware description may lose
the semantic structure upheld in the high-level language for
some algorithmic description. Description obscuration can
make verifying and debugging hardware designs difcult.
In the same regard, faulty hardware designs pose additional
challenges, such as tracing back to the offending high level
language statements. Although debugging techniques have
been proposed for HLS (i.e. [9], [10], they have yet to become
an industry practice.

High-level synthesis tools place a strong assumption that
the high-level description provided as input is bug-free, and
suitable for synthesis. Currently, producing bug-free code is
difcult, and hence the assumption cannot hold. Compiled
hardware designs from high-level synthesis could then suffer
from all possible bugs that occur in software. The scope of
bugs which could affect the generated hardware is not limited
to purely memory bugs or logic bugs; bugs related to threaded
behaviour are also subject to synthesis as many HLS tools
provide support for Pthreads. However, many bug-detection
and bug-correction systems exist (i.e. [1], [11], [12]) for high-
level
languages (such as C or C++). It would be logical
to inspect a high-level description before entering the HLS
process, as this may mitigate potential bugs which could be
synthesized to hardware.

Additionally, digital hardware devices can suffer from single
event upsets (SEU). Single event upsets (or more commonly
identied as bit ips or soft errors) occur when an environment
with free neutrons or alpha particles strike a silicon device and
ionize a silicon atom [13]. The ionization of the silicon atom
upsets the state in which the silicon device was presumably
in. SEUs can affect several circuit operations: transient circuit
pulses, memory corruption, and latch up. The latter is detri-
mental to device operation and can lead to overheating and/or
melting [13]. A model of how an SEU may occur is outlined
in Figure 1.

1The usage of optimization refers to compiler based optimizations/passes,
which modify the code for some specied purpose. HLS generally compile
high level descriptions through tool specic optimizations.

Rs = 1  M(cid:89)

(1  Ri)

i=1

(3)

It can be seen that n-Modular-Redundancy schemes provide
increased reliability. However, these replication schemes con-
sume n times more silicon area, and introduce latency into the
resulting fault tolerant system. Certain applications may not be
able to tolerate this area consumption or increase in latency.
Hence, other fault tolerance methods should be explored.

To address these issues, we introduce SiFT3, a method to
insert fault tolerance during the HLS process. SiFT provides
fault tolerance to the HLS process by primarily inspecting
high-level descriptions with a pre-existing tool, SATURN [1],
which is able to identify many latent bugs such as null
pointer bugs, memory bugs, etc. This addresses the bug-free
assumption placed on high-level descriptions. Upon successful
inspection of the high-level description, an HLS tool begins
the compilation process. Before completion of the compi-
lation, SiFT performs a compiler pass which proles and
gains knowledge of the high-level description at a function
level. SiFT proles each function to attempt to categorize
its behaviour through inspection of inputs & corresponding
outputs and produce a signature or characterization. These
signatures are then introduced back into the proled function
as an assertion. This allows for automatic detection of a
misbehaving function due to a bug inserted during high-level
synthesis or data corruption due to a signal event upset. SiFT
will be further detailed in Section III.

The remainder of this report is organized as follows. Sec-
tion II discusses related works. Section III discusses SiFT
in higher detail. We outline the progress made with SiFTs
implementation is Section IV. Finally, Section V discusses
evaluation techniques for SiFT.

II. RELATED WORK

A. Bug Detection Methods within High Level Synthesis
B. Correctness Checking Methods
C. Signature Analysis
D. Variational AutoEncoders

III. OUR APPROACH

In this section, we detail the behaviour of SiFT.

A. Modied High-Level Synthesis Flow

SiFT is a tool which aims to provide fault tolerance within
High-Level Synthesis and hence, we modify an existing HLS
tool, LegUp [3] to be tted for SiFT. Prior to SiFTs modi-
cations, the LegUp tool from the University of Toronto was
built within the LLVM framework, and operated on LLVMs
intermediate representation (IR) of a high-level description to
compile to a hardware description. The general operation is
outlined in Figure 2.

Referring to Figure 2, SiFT is only concerned with steps
(1) and (3) of this system ow. In (1) a high-level description

Fig. 1. An illustration of a single event upset with a transistor, taken from
[13]

HLS targets both application specic integrated circuits
(ASIC) designs and eld programmable gate arrays (FPGA)
designs, both of which consist of digital hardware comprised
of silicon. As identied, SEUs are a threat to these devices and
possible effects from SEUs should be mitigated. It is worth
noting that ASIC designs are more susceptible to SEU effects
due to their abudant usages of registers/ip-ops. Nevertheless,
static random access memory (SRAM) based FPGAs are at
risk of SEUs, and have degrade circuit behaviour. This class
of FPGAs represent circuit behaviour as a stream of bits named
conguration bits. These conguration bits are then stored on
SRAM cells located on the FPGA. Hence, an SEU thatt occurs
in an area where the conguration bits reside would cause
unpredictability in circuit behaviour.

Yet, high-level synthesis offers limited support

to SEU
mitigation & fault tolerance, or use practices that are expen-
sive2 (i.e. [14], [15], [16]), such as an n-Modular-Redundancy
scheme. n-Modular-Redundancy schemes for system level or
function level fault tolerance towards SEU aim to replicate the
system or function an n number of times in order to increase
reliability.

The reliability of a system can be represented as a prob-
abilistic model [17]. Reliability is dened as the ability to
perform a desired task correctly against some period of op-
eration. With historical knowledge of behaviour pertaining to
some item  on the duration of execution for some task T ,
we can make some statistical claim of s reliability. This can
be described as a rate, , which denotes the hazard rate of a
. We can model the reliability R with:

R = et,

0  R  1

(1)

Generally, we deal with a system comprised of many items
connected through serial or parallel means [?]. Hence, we can
model the overall probability of each case:

In a serial system, we evaluate the reliability through a
multiplicative fashion, where the reliability of the system S
with N serial components can be modeled as:

N(cid:89)

Rs =

Ri

(2)

The reliability of a parallel system with M parallel compo-

nents is represented as:

i=1

2expensive refers to latency and area considerations for hardware

3Signature based Fault Tolerance

as Function Certication is described in Section III-E.
Function Certication refers to node (4) in Figure 3

B. Hesitant Inspection

The bug-free assumption placed on high-level descriptions
makes SiFT hesitant
to continue to the HLS compilation
process, and hence checks this description for any possible
bugs that can be determined statically. We utilize SATURN,
a boolean satisability approach to bug detection. We employ
this static bug detection mechanism for several reasons, (a)
SATURN is scalable, and was intended to be that way, (b)
it comes working out of the box and has a variety of bug
checking templates, (c) it is open source. Although other bug
detection techniques could be investigated, SATURN seems
to work well for the types of high-level description typical to
HLS, which are algorithmic descriptions.

C. Function Inspection

Once the high-level description passes SATURNs bug
detection mechanism, SiFT permits LegUp to begin opera-
tion. LegUp rst compiles the high-level description in C to
LLVMs bitcode. Immediately after the compilation process,
SiFT is called by LegUp as an LLVM pass and begins
the Function Inspection process. We implement SiFT as a
specialized FunctionPass which is a template from the
LLVM framework. Our pass allows for proling of function
arguments and return values, and their behaviour at runtime.
To prole function behaviour, we implemented a JIT compiler
within our pass which can execute bitcode on demand. Hence,
we can execute particular functions described in the compiled
bitcode without having to link into main. When using the
JIT compiler on a per-function basis, we either generate
inputs randomly or utilized supplied values from the high-level
description (which correspond to the argument data types)
for the function. This information, as well as any output
information is stored for analysis. This function pass also
provides the ability to automatically insert additional bitcode
into the function.

D. Function Characterization

Once a function has been proled against known input cases
or has completed a randomized execution from our generated
inputs, SiFT attempts to generalize the function behaviour in
a number of ways:

1) It inspects the return value of a function. If one exists,
SiFT identies if the return value is possibly signed
or unsigned. If the value is signed, we then check the
range of outputs collected at Function Inspection. If a
constraint is detect on the output SiFT then classies
this range as a signature of function behaviour.

2) If data described by the high-level description was used

during the

E. Function Certication

Once a signature or function characterization has been
obtained, SiFT generates a function specic assert against the

Fig. 2. An overview of the LegUp tool, taken from [3].

is compiled to LLVMs bitcode4 through use of Clang [18].
It is important to highlight that the IR could be interpreted as
an abstracted assembly language. This means that the IR is
a detailed set of abstracted machine code. With this bitcode,
LegUp performs HLS specic LLVM passes upon this bitcode,
to eventually produce a hardware description as (3).

SiFTs modication to LegUp can be viewed in a system

level diagram of operation. This is depicted in Figure 3.

Fig. 3. SiFTs integration into LegUp.

We will now describe SiFT with reference to Figure 3. SiFT

has the following behaviour:

(a) Static code inspection for various bugs, which we refer
to as Hesitant Inspection. This is outlined in Sec-
tion III-B. This state of SiFT refers to number nodes
(1) and (2) in Figure 3.

(b) Code proling through JITd execution of the high-
level description to gain information of function be-
haviour, which is referred to as Function Inspection
and is described in Section III-C. Function Inspection
is highlighted in Figure 3 at nodes (3) and (4).

(c) Signature generation through bit-pattern analysis tech-
niques or return value enforcement, which is named
Function Characterization. This operation is detailed in
Section III-D. Function Characterization refers to node
(4) in Figure 3.

(d) Automatic insertion of assertion logic which identies
if a function is behaving correctly, which we refer to

4the IR is encoded in bitcode.

REFERENCES

[1] Y. Xie and A. Aiken, Saturn: A sat-based tool for bug detection, in
International Conference on Computer Aided Verication, pp. 139143,
Springer, 2005.

[2] C. Lattner and V. Adve, Llvm: A compilation framework for lifelong
program analysis & transformation, in Proceedings of the international
symposium on Code generation and optimization: feedback-directed and
runtime optimization, p. 75, IEEE Computer Society, 2004.

[3] A. Canis, J. Choi, M. Aldham, V. Zhang, A. Kammoona, J. H. An-
derson, S. Brown, and T. Czajkowski, Legup: high-level synthesis
for fpga-based processor/accelerator systems, in Proceedings of the
19th ACM/SIGDA international symposium on Field programmable gate
arrays, pp. 3336, ACM, 2011.

[4] Y. Hara, H. Tomiyama, S. Honda, H. Takada, and K. Ishii, Chstone: A
benchmark program suite for practical c-based high-level synthesis, in
Circuits and Systems, 2008. ISCAS 2008. IEEE International Symposium
on, pp. 11921195, IEEE, 2008.

[5] Q. I. Altera, Handbook version 13.1, QII52005-13.1. 0, vol. 2, pp. 12

1, 2013.

[6] C. Zhang, P. Li, G. Sun, Y. Guan, B. Xiao, and J. Cong, Optimizing
fpga-based accelerator design for deep convolutional neural networks,
in Proceedings of the 2015 ACM/SIGDA International Symposium on
Field-Programmable Gate Arrays, pp. 161170, ACM, 2015.

[7] C. Leber, B. Geib, and H. Litz, High frequency trading acceleration
using fpgas, in Field Programmable Logic and Applications (FPL),
2011 International Conference on, pp. 317322, IEEE, 2011.

[8] T. Kropf, Introduction to formal hardware verication. Springer Science

& Business Media, 2013.

[9] N. Calagar, S. D. Brown, and J. H. Anderson, Source-level debugging
for fpga high-level synthesis, in Field Programmable Logic and Appli-
cations (FPL), 2014 24th International Conference on, pp. 18, IEEE,
2014.

[10] J. Goeders and S. J. Wilton, Effective fpga debug for high-level synthe-
sis generated circuits, in Field Programmable Logic and Applications
(FPL), 2014 24th International Conference on, pp. 18, IEEE, 2014.

[11] C. Cadar, D. Dunbar, D. R. Engler, et al., Klee: Unassisted and auto-
matic generation of high-coverage tests for complex systems programs.,
[12] N. Nethercote and J. Seward, Valgrind: A program supervision frame-
work, Electronic notes in theoretical computer science, vol. 89, no. 2,
pp. 4466, 2003.

[13] J. Hussein and G. Swift, Single-event upsets, 2012.
[14] S. Tosun, N. Mansouri, E. Arvas, M. Kandemir, and Y. Xie, Reliability-
centric high-level synthesis, in Proceedings of
the conference on
Design, Automation and Test in Europe-Volume 2, pp. 12581263, IEEE
Computer Society, 2005.

[15] C. Fibich, M. Horauer, and R. Obermaisser, Hlshield: a reliability en-
hancement framework for high-level synthesis, in Industrial Embedded
Systems (SIES), 2017 12th IEEE International Symposium on, pp. 110,
IEEE, 2017.

[16] G. Lee, D. Agiakatsikas, T. Wu, E. Cetin, and O. Diessel, Tlegup: A
tmr code generation tool for sram-based fpga applications using hls, in
Field-Programmable Custom Computing Machines (FCCM), 2017 IEEE
25th Annual International Symposium on, pp. 129132, IEEE, 2017.

[17] R. E. Barlow and F. Proschan, Statistical theory of reliability and life
testing: probability models, tech. rep., Florida State Univ Tallahassee,
1975.

[18] C. Lattner, Llvm and clang: Next generation compiler technology, in

The BSD Conference, pp. 12, 2008.

Function Characterization. This assertion is produced as IR
instructions, which are then inserted at the output of a function.
The function is then modied to adhere to this assertion
conditionally. Once this has completed, SiFT has effectively
added fault tolerance to the given high-level description, and
this will now propagate to the hardware description language.

IV. IMPLEMENTATION STATUS

SiFT is still in development. However, the following outline
what has been accomplished, and what needs to be completed:
 The bug detection system SATURN [1] has been ac-
quired and tested on several user-dened .c descriptions.
As noted, SATURN comes working-out-of-the-box, with
many bug detection templates available. We need to
automate the usage of this bug detection system.

 Both Clang and LLVM have been installed and studied

for its usage and for safe modications.

 We have already developed an LLVM FunctionPass
which is able to prole the IR at a function level and
determine the input and output arguments of a particular
function. This pass also includes a JIT compiler for
a functions bitcode, which allows the pass to identify
function behaviour. We have also tted this pass with
the ability to insert automatically generated IR into a
functions code. We need to identify ways of producing
the Function Characterization.

 We have installed LegUp onto an EECG machine. LegUp
has been tested, and inspected to see how to include
modications. We need to integrate SiFTs function pass
into LegUp and prepend SiFTs Hesitant Inspection state
as a preprocessing step to LegUp.

V. EVALUATION OF SIFT

To evaluate SiFT we will perform the following:
 Record the number of bugs possibly detected prior to
HLS, to note if there is any correlation with impacts on
the hardwares estimated latency, performance and area
consumption.

 Record the hardwares estimated latency, performance
and area consumption after compiling the CHStone [4]
benchmark with use of SiFT. Also record these metrics
without the use of SiFT and using triple modular redun-
dancy.

 Attempt to utilize Alteras Quartus Prime Fault Injection
IP Core, to inject faults into the conguration bits of
an FPGA. We then will record the number of times the
FPGA with SiFTs fault tolerance safely exits operation
due to Function Certication failures (failure for a func-
tion to operate correctly). 5

This will evaluate SiFT on all that is was designed to do,
which was to provide fault tolerance, automatically to HLS,
while ensuring the high-level description is safe (i.e. has based
the Hesitant Inspection state of SiFT) for compilation.

5This is subject to which version of Quartus the school has available, and/or

if we can get access to this another way.

